<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Monty</title>
  <link rel="icon" type="image/png" href="favicon.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .btn-primary { background-color:#161f6d; }
    .btn-primary:hover { background-color:#0f1751; }
    .text-brand { color:#131f72; }
    th, td { white-space: nowrap; }
    table { border-collapse: collapse; width: 100%; }
    th { font-weight: 600; }
    #foundersScroll::-webkit-scrollbar { height: 8px; }
    #foundersScroll::-webkit-scrollbar-thumb {
      background-color: #cbd5e1; border-radius: 4px;
    }
    #searchResults.hidden,
    #recommendedResults.hidden {
      display: none !important;
    }
    .tab-btn {
      transition: all 0.25s ease;
    }

    .tab-btn:hover {
      color: #161f6d; /* your brand color */
    }

    .tab-btn.active {
      border-color: #161f6d;
      color: #161f6d;
    }

    .hero-title {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      letter-spacing: 0.02em;
      font-weight: 400;
    }

    .hero-title-line1 {
      font-size: 1.25rem;
      font-weight: 400;
      font-style: normal;
      opacity: 0.8;
    }

    @media (min-width: 640px) {
      .hero-title-line1 {
        font-size: 1.75rem;
      }
    }

    .hero-title-line2 {
      font-size: 1.75rem;
      font-weight: 500;
      font-style: normal;
      line-height: 1.3;
    }

    @media (min-width: 640px) {
      .hero-title-line2 {
        font-size: 2.5rem;
      }
    }

    /* Sidebar styling */
    .sidebar-btn {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      font-weight: 300;
      font-size: 0.95rem;
      letter-spacing: 0.02em;
      transition: all 0.2s ease;
      color: rgba(255, 255, 255, 0.85);
    }

    .sidebar-btn:hover {
      color: rgba(255, 255, 255, 1);
      background-color: rgba(255, 255, 255, 0.1);
    }

    .sidebar-btn.bg-blue-700 {
      background-color: rgba(255, 255, 255, 0.15);
      color: rgba(255, 255, 255, 1);
      font-weight: 400;
    }

    /* Module card styling */
    .module-card {
      background: linear-gradient(to bottom, #ffffff, #fafbfc);
      border: 1px solid rgba(226, 232, 240, 0.8);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
      transition: all 0.3s ease;
    }

    .module-card:hover {
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.08), 0 4px 6px -2px rgba(0, 0, 0, 0.04);
      transform: translateY(-2px);
    }

    .module-title {
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    /* Mobile sidebar styles */
    .sidebar-mobile-overlay {
      display: none;
    }

    .sidebar-container {
      position: relative;
      height: 100%;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-container aside {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    @media (max-width: 768px) {
      .sidebar-mobile-overlay {
        position: fixed;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 40;
        display: none;
      }
      
      .sidebar-mobile-overlay.active {
        display: block;
      }
      
      .sidebar-container {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        width: 16rem;
        height: 100vh;
        z-index: 50;
        transform: translateX(-100%);
        transition: transform 0.3s ease-in-out;
      }
      
      .sidebar-container.active {
        transform: translateX(0);
      }
    }

    /* Hamburger menu button */
    .hamburger-btn {
      display: none;
      position: fixed;
      top: 1rem;
      left: 1rem;
      z-index: 60;
      background-color: #161F6D;
      color: white;
      border: none;
      padding: 0.75rem;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .hamburger-btn:hover {
      background-color: #0f1751;
    }

    @media (max-width: 768px) {
      .hamburger-btn {
        display: block;
      }
    }

    /* Responsive hero section height */
    .hero-section-height {
      min-height: 30vh;
    }

    @media (min-width: 768px) {
      .hero-section-height {
        min-height: 40vh;
      }
    }

    </style>
</head>
<body class="h-screen flex overflow-hidden" style="background: linear-gradient(to bottom right, #F9FAFF, #E3F1FF, #E3F1FF);">
  <!-- Hamburger Menu Button (Mobile Only) -->
  <button id="hamburgerBtn" class="hamburger-btn" onclick="toggleSidebar()" aria-label="Toggle menu">
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
    </svg>
  </button>

  <!-- Mobile Overlay -->
  <div id="sidebarOverlay" class="sidebar-mobile-overlay" onclick="toggleSidebar()"></div>

  <!-- Sidebar Container -->
  <div class="sidebar-container">
    <aside class="w-64 text-white p-6 flex flex-col gap-3" style="background-color: #161F6D;">
    <div class="mb-6 pl-3 flex items-center justify-between">
      <img src="montage_logo.png" alt="Monty Logo" class="h-12 object-contain cursor-pointer hover:opacity-80 transition-opacity" onclick="showModule('welcomeModule')">
      <button onclick="toggleSidebar()" class="md:hidden text-white hover:text-gray-200 p-2" aria-label="Close menu">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>

    <button id="btn-welcomeModule"
        class="sidebar-btn text-left py-3 px-4 rounded"
        onclick="showModule('welcomeModule')">
  Home
</button>

    <button id="btn-foundersModule"
            class="sidebar-btn text-left py-3 px-4 rounded"
            onclick="showModule('foundersModule')">
      Monty's Sourcing
    </button>
    <button id="btn-dealsModule"
            class="sidebar-btn text-left py-3 px-4 rounded"
            onclick="showModule('dealsModule')">
      Deals
    </button>
    <button id="btn-interestingPeopleModule"
            class="sidebar-btn text-left py-3 px-4 rounded"
            onclick="showModule('interestingPeopleModule')">
      Interesting People
    </button>
    <button id="btn-tasteTreeModule"
            class="sidebar-btn text-left py-3 px-4 rounded"
            onclick="showModule('tasteTreeModule')">
      Team Preferences
    </button>
    <button id="btn-prospectingModule"
            class="sidebar-btn text-left py-3 px-4 rounded"
            onclick="showModule('prospectingModule')">
      Prospecting
    </button>
    <button id="btn-valuationModule"
            class="sidebar-btn text-left py-3 px-4 rounded"
            onclick="showModule('valuationModule')">
      Public Markets
    </button>
  </aside>
  </div>

  <!-- Main content area -->
  <main class="flex-1 p-4 sm:p-6 md:p-8 overflow-y-auto">
    <!-- Welcome page (default) -->
<div id="welcomeModule" class="space-y-10">
  <!-- Hero Section -->
  <div class="w-full flex items-center justify-start pl-4 sm:pl-6 md:pl-8 hero-section-height">
    <div class="hero-title text-brand">
      <div class="hero-title-line1">
        Monty's  
      </div>
      <div class="hero-title-line2">
        Data and Sourcing Results
      </div>
    </div>
  </div>
  
  <!-- Dashboard Section -->
  <div class="w-full max-w-7xl mx-auto">
    
    <!-- Dashboard Grid - Easy to add more modules -->
    <div id="dashboardGrid" class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      
      <!-- Recent Founder Recommendations Module -->
      <div class="module-card rounded-xl p-6">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-xl module-title text-brand">Recent sourcing recommendations</h3>
          <button onclick="showModule('foundersModule')" class="text-sm text-blue-600 hover:text-blue-800 font-medium transition-colors">
            View All →
          </button>
        </div>
        
        <div id="dashboardFoundersLoading" class="hidden text-center py-4">
          <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
          <p class="text-sm text-gray-600 mt-2">Loading...</p>
        </div>
        
        <div id="dashboardFoundersList" class="space-y-3">
          <!-- Cards will be inserted here -->
        </div>
      </div>

      <!-- Recent Pre-Seed Deals Module -->
      <div class="module-card rounded-xl p-6">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-xl module-title text-brand">Recent pre-seed deals</h3>
          <button onclick="showModule('dealsModule')" class="text-sm text-blue-600 hover:text-blue-800 font-medium transition-colors">
            View All →
          </button>
        </div>
        
        <div id="dashboardDealsLoading" class="hidden text-center py-4">
          <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
          <p class="text-sm text-gray-600 mt-2">Loading...</p>
        </div>
        
        <div id="dashboardDealsList" class="space-y-3">
          <!-- Cards will be inserted here -->
        </div>
      </div>
      
    </div>
  </div>
</div>


    <div id="valuationModule" class="space-y-10 hidden">


  <!-- Single Stock Section -->
  <div class="bg-white rounded-xl shadow-lg w-full max-w-3xl p-6 space-y-6 mx-auto">

    <div class="flex gap-2">
      <input id="tickerInput" type="text" placeholder="Enter ticker (e.g. AAPL)"
        class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
        onkeypress="if(event.key==='Enter') fetchData()" />
      <button onclick="fetchData()" class="btn-primary text-white px-4 py-2 rounded-lg font-semibold">Search</button>
    </div>

    <div id="loading" class="hidden text-center py-4">
      <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
      <p class="text-sm text-gray-600 mt-2">Loading...</p>
    </div>

    <div id="errorBox" class="hidden bg-red-50 border border-red-200 text-red-700 text-sm rounded-lg p-3"></div>

    <div id="results" class="hidden space-y-4">
      <div class="flex items-center justify-between">
        <h2 id="companyHeader" class="text-lg font-bold text-brand"></h2>
        <p id="stockPrice" class="text-xl font-semibold text-green-600"></p>
      </div>

      <div class="grid grid-cols-2 gap-3">
        <div class="bg-gray-50 p-3 rounded-lg"><p class="text-xs text-gray-500">Revenue</p><p id="revenue" class="font-semibold text-gray-800">—</p></div>
        <div class="bg-gray-50 p-3 rounded-lg"><p class="text-xs text-gray-500">P/E</p><p id="pe" class="font-semibold text-gray-800">—</p></div>
        <div class="bg-gray-50 p-3 rounded-lg"><p class="text-xs text-gray-500">P/S</p><p id="ps" class="font-semibold text-gray-800">—</p></div>
        <div class="bg-gray-50 p-3 rounded-lg"><p class="text-xs text-gray-500">Market Cap</p><p id="marketCap" class="font-semibold text-gray-800">—</p></div>
      </div>

      <button onclick="openModal()" class="w-full text-sm mt-2 py-2 rounded-lg border border-gray-300 hover:bg-gray-100">
        View Full Income Statement →
      </button>
    </div>
  </div>

  <!-- Vertical / Portfolio Comps Section -->
  <div id="verticalCompsPicker" class="bg-white rounded-xl shadow-lg w-full max-w-3xl p-6 space-y-5 mx-auto">
    <h3 class="text-lg font-semibold text-gray-800">Vertical / Portfolio Comps</h3>
    <div class="space-y-4">
      <div>
        <label class="block text-sm font-medium text-gray-700 mb-2">By Vertical</label>
        <input id="verticalInput" type="text" placeholder="e.g. Gaming, Fintech, AI Infrastructure"
          class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" />
      </div>
      <div>
        <label class="block text-sm font-medium text-gray-700 mb-2">By Portfolio Company</label>
        <select id="portfolioCompanySelect"
          class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
          <option value="">Select portfolio company</option>
        </select>
      </div>
    </div>
    <button type="button"
            onclick="fetchVerticalComps()"
            class="w-full btn-primary text-white py-3 px-6 rounded-lg font-semibold">
      Get Comps
    </button>
  </div>

  <!-- Industry Comparison Section -->
  <div id="industryPicker" class="bg-white rounded-xl shadow-lg w-full max-w-3xl p-6 space-y-5 mx-auto">
    <div>
      <label class="block text-sm font-medium text-gray-700 mb-2">Select Industry</label>
      <select id="industrySelect"
              onchange="updateSectorOptions()"
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
        <option value="">Select Industry</option>
      </select>
    </div>

    <div>
      <label class="block text-sm font-medium text-gray-700 mb-2">Select Sector</label>
      <select id="sectorSelect"
              onchange="updateIndustryGroupOptions()"
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled>
        <option value="">Select Sector</option>
      </select>
    </div>

    <div>
      <label class="block text-sm font-medium text-gray-700 mb-2">Select Industry Group (optional)</label>
      <select id="industryGroupSelect"
              class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 bg-gray-100"
              disabled>
        <option value="">All Groups in Sector</option>
      </select>
    </div>

    <button type="button"
            onclick="fetchIndustryComparison()"
            class="w-full btn-primary text-white py-3 px-6 rounded-lg font-semibold">
      Compare Companies
    </button>
  </div>

</div>


  <div id="modalOverlay" class="hidden fixed inset-0 bg-black bg-opacity-50 z-40 flex items-center justify-center" onclick="closeModal()"></div>
  <div id="modal" class="hidden fixed inset-8 bg-white rounded-xl shadow-2xl z-50 overflow-auto p-6">
    <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-bold text-brand">Income Statement</h2>
        <button onclick="closeModal()" class="text-2xl leading-none text-gray-700">×</button>
    </div>
    <div id="modalBody"></div>
    </div>
    </div> <!-- end valuationModule -->
    <div id="foundersModule" class="hidden">
  <div class="module-card rounded-xl w-full p-6 space-y-4">
<!-- Tabs (always visible) -->
<div class="flex justify-center border-b border-gray-300 mt-4">
  <button
    id="recommendedTab"
    onclick="showTab('recommended')"
    class="tab-btn border-b-2 border-blue-700 text-blue-700 font-semibold px-6 py-2">
    Recommended
  </button>
  <button
    id="searchTab"
    onclick="showTab('search')"
    class="tab-btn border-b-2 border-transparent text-gray-600 hover:text-blue-700 px-6 py-2">
    Search Database
  </button>
</div>


<!-- Recommended Filters -->
<div id="treePathFilters" class="space-y-3 hidden">
  <label class="block text-sm font-medium text-gray-700 mb-1">
    Filter by vertical 
  </label>

  <select id="treeLevel1"
          onchange="updateTreeLevel2(); loadRecommendedFiltered();"
          class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
    <option value="">All</option>
  </select>

<div id="treeLevel2Container" class="hidden">
  <select id="treeLevel2"
          onchange="updateTreeLevel3(); loadRecommendedFiltered();"
          class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
    <option value="">All</option>
  </select>
</div>


<div id="treeLevel3Container" class="hidden">
  <select id="treeLevel3"
          onchange="loadRecommendedFiltered();"
          class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
    <option value="">All</option>
  </select>
</div>
</div>
<!-- Search Filters -->
<div id="searchPanel" class="space-y-3 hidden">
  <!-- Tree Path Filters for Search -->
<div class="space-y-2">
  <label class="block text-sm font-medium text-gray-700 mb-1">
    Optional filters
  </label>

  <!-- Cascading Category Menu -->
  <div class="relative">
    <button type="button" 
            onclick="window.toggleCategoryMenu()"
            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 bg-white text-left flex items-center justify-between">
      <span>Select category</span>
      <span class="text-gray-400">▼</span>
    </button>
    
    <!-- Cascading Menu Container -->
    <div id="categoryCascadeMenu" class="hidden absolute z-20 mt-1 flex gap-1 bg-white border border-gray-300 rounded-lg shadow-xl p-2">
      <!-- Level 1: Top Level Categories -->
      <div id="categoryLevel1" class="w-48 border-r border-gray-200 pr-2">
        <div class="font-semibold text-sm text-gray-700 mb-2 px-2">Top Level</div>
        <div class="max-h-60 overflow-y-auto">
          <label class="flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded">
            <input type="checkbox" 
                   class="mr-2" 
                   onchange="toggleTopLevelOption('all')"
                   id="searchTopLevelAll">
            <span class="text-sm">All Verticals</span>
          </label>
          <div id="searchTopLevelOptions" class="border-t border-gray-200 mt-1 pt-1">
            <!-- Options will be populated here -->
          </div>
        </div>
      </div>

      <!-- Level 2: Subcategories (appears when top level is selected) -->
      <div id="categoryLevel2" class="hidden w-48 border-r border-gray-200 pr-2">
        <div class="font-semibold text-sm text-gray-700 mb-2 px-2">Subcategory</div>
        <div class="max-h-60 overflow-y-auto">
          <div id="searchSubcategoryOptions">
            <!-- Options will be populated here -->
          </div>
        </div>
      </div>

      <!-- Level 3: Sub-Subcategories (appears when subcategory is selected) -->
      <div id="categoryLevel3" class="hidden w-48">
        <div class="font-semibold text-sm text-gray-700 mb-2 px-2">Sub-Subcategory</div>
        <div class="max-h-60 overflow-y-auto">
          <div id="searchSubSubcategoryOptions">
            <!-- Options will be populated here -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Selected Categories Tags -->
  <div id="selectedCategoriesTags" class="flex flex-wrap gap-2 mt-2 min-h-[2rem]">
    <!-- Tags will be displayed here -->
  </div>
</div>


  <input id="searchKeyword" type="text"
         placeholder="Keyword (e.g. company or founder)"
         class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">

  <label class="block text-sm font-medium text-gray-700 mb-1">
    Location
  </label>
  <!-- Cascading Location Menu -->
  <div class="relative">
    <button type="button" 
            onclick="window.toggleLocationMenu()"
            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 bg-white text-left flex items-center justify-between">
      <span>Select location</span>
      <span class="text-gray-400">▼</span>
    </button>
    
    <!-- Cascading Menu Container -->
    <div id="locationCascadeMenu" class="hidden absolute z-20 mt-1 flex gap-1 bg-white border border-gray-300 rounded-lg shadow-xl p-2">
      <!-- Level 1: Countries -->
      <div id="locationLevel1" class="w-48 border-r border-gray-200 pr-2">
        <div class="font-semibold text-sm text-gray-700 mb-2 px-2">Country</div>
        <div class="max-h-60 overflow-y-auto">
          <div id="locationCountryOptions">
            <!-- Options will be populated here -->
          </div>
        </div>
      </div>

      <!-- Level 2: States (appears when country is selected) -->
      <div id="locationLevel2" class="hidden w-48">
        <div class="font-semibold text-sm text-gray-700 mb-2 px-2">State/Region</div>
        <div class="max-h-60 overflow-y-auto">
          <div id="locationStateOptions">
            <!-- Options will be populated here -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Selected Locations Tags -->
  <div id="selectedLocationsTags" class="flex flex-wrap gap-2 mt-2 min-h-[2rem]">
    <!-- Tags will be displayed here -->
  </div>

  <input id="searchTag" type="text"
         placeholder="Tag"
         class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">

  <button onclick="searchFounders()"
          class="w-full mt-2 btn-primary text-white py-2 px-4 rounded-lg font-semibold">
    Search
  </button>
</div>



    <!-- Two-column layout -->
    <div class="flex gap-6 mt-6">
      <!-- Left: scroll list -->
      <div class="w-1/2">
        <div id="foundersLoading" class="hidden text-center py-4">
          <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
          <p class="text-sm text-gray-600 mt-2">Loading...</p>
        </div>

        <!-- Recommended results -->
      <div id="recommendedResults" class="hidden overflow-y-auto max-h-[700px] border border-gray-200 rounded-lg p-3">
        <div id="recommendedScroll" class="flex flex-col gap-4"></div>
      </div>

      <!-- Search results -->
      <div id="searchResults"
     class="hidden overflow-y-auto max-h-[700px] border border-gray-200 rounded-lg p-3">
  <div id="searchScroll" class="flex flex-col gap-4"></div>
</div>

      </div>

      <!-- Right: detail panel -->
      <div id="founderDetailPanel" class="w-1/2 bg-gray-50 border border-gray-200 rounded-lg p-4 hidden">
        <h3 id="founderDetailTitle" class="text-xl font-bold text-brand mb-3">Founder Details</h3>
        <div id="founderDetailBody" class="text-sm text-gray-700 space-y-2"></div>
      </div>
    </div>
  </div>
</div>

    <!-- Interesting People Module -->
    <div id="interestingPeopleModule" class="hidden">
      <div class="module-card rounded-xl w-full p-6 space-y-4">
        <p class="text-gray-600 mt-8 mb-2 px-6 py-4">
          This page displays potential future founders based on their profiles, skills, and recent activity. 
          People are ranked by their potential interest as founders, with those who have recently been acquired, 
          are building new ventures, or show strong entrepreneurial indicators appearing first.
        </p>
        <p class="text-sm text-gray-500 mb-8 px-6">
          Source: <a href="https://www.aviato.co/" target="_blank" class="text-blue-600 hover:text-blue-800 underline">Aviato</a>
        </p>
        <!-- Two-column layout -->
        <div class="flex gap-6 mt-6">
          <!-- Left: scroll list -->
          <div class="w-1/2">
            <div id="peopleLoading" class="hidden text-center py-4">
              <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
              <p class="text-sm text-gray-600 mt-2">Loading...</p>
            </div>

            <!-- People results -->
            <div id="peopleResults" class="hidden overflow-y-auto max-h-[700px] border border-gray-200 rounded-lg p-3">
              <div id="peopleScroll" class="flex flex-col gap-4"></div>
            </div>
          </div>

          <!-- Right: detail panel -->
          <div id="personDetailPanel" class="w-1/2 bg-gray-50 border border-gray-200 rounded-lg p-4 hidden">
            <h3 id="personDetailTitle" class="text-xl font-bold text-brand mb-3">Person Details</h3>
            <div id="personDetailBody" class="text-sm text-gray-700 space-y-2"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Taste Tree Module -->
    <div id="tasteTreeModule" class="hidden">
      <div class="module-card rounded-xl w-full p-6 space-y-4">
        <div class="mb-4">
          <h2 class="text-2xl font-bold text-brand mb-2">Team Interests Management</h2>
          <p class="text-gray-600 text-sm">
            Manage which categories are of interest to each user.
          </p>
        </div>

        <!-- Loading indicator -->
        <div id="tasteTreeLoading" class="hidden text-center py-4">
          <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
          <p class="text-sm text-gray-600 mt-2">Loading...</p>
        </div>

        <!-- Error message -->
        <div id="tasteTreeError" class="hidden text-center py-4">
          <p class="text-red-500 text-sm"></p>
        </div>

        <!-- Two-panel layout -->
        <div id="tasteTreeContent" class="hidden flex gap-6" style="min-height: 600px;">
          <!-- Left Panel: Users List -->
          <div class="w-1/3 border border-gray-200 rounded-lg p-4 bg-gray-50">
            <div class="mb-4">
              <h3 class="font-semibold text-brand mb-2">Users</h3>
              <input
                type="text"
                id="userSearchInput"
                placeholder="Search users..."
                class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-500"
                oninput="filterUsers()"
              />
            </div>
            <div id="usersList" class="overflow-y-auto max-h-[550px] space-y-2">
              <!-- Users will be rendered here -->
            </div>
          </div>

          <!-- Right Panel: User Tags Management -->
          <div class="flex-1 border border-gray-200 rounded-lg p-6 bg-white">
            <div id="noUserSelected" class="text-center py-12 text-gray-500">
              <p class="text-lg mb-2">Select a user from the left panel</p>
              <p class="text-sm">to view and manage their category tags</p>
            </div>

            <div id="userTagsPanel" class="hidden">
              <!-- User Header -->
              <div class="mb-6 pb-4 border-b border-gray-200">
                <h3 id="selectedUserName" class="text-xl font-bold text-brand mb-1"></h3>
                <p id="selectedUserTagCount" class="text-sm text-gray-600"></p>
              </div>

              <!-- Current Tags Section -->
              <div class="mb-6">
                <h4 class="font-semibold text-gray-700 mb-3">Current Tags</h4>
                <div id="currentTagsList" class="flex flex-wrap gap-2 min-h-[60px] p-3 border border-gray-200 rounded-lg bg-gray-50">
                  <!-- Tags will be rendered here -->
                </div>
              </div>

              <!-- Search and Add Tags Section -->
              <div class="mb-6">
                <h4 class="font-semibold text-gray-700 mb-3">Add Tags</h4>
                
                <!-- Tabs for Search vs Browse -->
                <div class="flex gap-2 mb-3 border-b border-gray-200">
                  <button
                    id="searchTabBtn"
                    onclick="switchTagMode('search')"
                    class="px-4 py-2 text-sm font-medium border-b-2 border-blue-600 text-blue-600"
                  >
                    Search
                  </button>
                  <button
                    id="browseTabBtn"
                    onclick="switchTagMode('browse')"
                    class="px-4 py-2 text-sm font-medium border-b-2 border-transparent text-gray-600 hover:text-gray-800"
                  >
                    Browse
                  </button>
                </div>

                <!-- Search Mode -->
                <div id="searchMode" class="tag-mode">
                  <input
                    type="text"
                    id="tagSearchInput"
                    placeholder="Search categories..."
                    class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 mb-3"
                    oninput="searchCategories()"
                  />
                  <div id="tagSearchResults" class="max-h-[300px] overflow-y-auto border border-gray-200 rounded-lg hidden">
                    <!-- Search results will be rendered here -->
                  </div>
                </div>

                <!-- Browse Mode -->
                <div id="browseMode" class="tag-mode hidden">
                  <div class="mb-3">
                    <input
                      type="text"
                      id="browseFilterInput"
                      placeholder="Filter categories..."
                      class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                      oninput="filterBrowseTree()"
                    />
                  </div>
                  <div id="categoryBrowseTree" class="max-h-[300px] overflow-y-auto border border-gray-200 rounded-lg p-3 bg-gray-50">
                    <!-- Category tree will be rendered here -->
                  </div>
                </div>
              </div>

              <!-- Pending Changes Indicator -->
              <div id="pendingChangesIndicator" class="hidden mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                <p class="text-sm text-yellow-800">
                  <span id="pendingChangesCount">0</span> changes pending
                </p>
              </div>

              <!-- Save Button -->
              <div class="flex justify-end">
                <button
                  id="saveUserChangesBtn"
                  onclick="saveUserChanges()"
                  disabled
                  class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                >
                  Save Changes
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Prospecting Module -->
    <div id="prospectingModule" class="hidden">
      <div class="module-card rounded-xl w-full p-6 space-y-4">
        <p class="text-gray-600 mt-8 mb-10 px-6 py-4">
          Use this tool to search for prospects based on keywords, role, and company name. 
          Enter your search criteria below and click search to find matching prospects.
        </p>
        
        <!-- Search Form -->
        <div class="space-y-4">
          <div id="prospectingErrorBox" class="hidden bg-red-50 border border-red-200 text-red-700 text-sm rounded-lg p-3"></div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Keywords <span class="text-gray-500 text-xs">(one keyword only)</span>
            </label>
            <input 
              id="prospectingKeywords" 
              type="text" 
              placeholder="Enter one keyword (e.g. machine learning)"
              class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Role <span class="text-gray-500 text-xs">(one role only)</span>
            </label>
            <input 
              id="prospectingRole" 
              type="text" 
              placeholder="Enter one role (e.g. CEO)"
              class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Company Name <span class="text-gray-500 text-xs">(one company only)</span>
            </label>
            <input 
              id="prospectingCompany" 
              type="text" 
              placeholder="Enter one company name"
              class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <button 
            onclick="searchProspects()"
            class="w-full mt-4 btn-primary text-white py-3 px-6 rounded-lg font-semibold">
            Search
          </button>
        </div>

        <!-- Loading indicator -->
        <div id="prospectingLoading" class="hidden text-center py-4">
          <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
          <p class="text-sm text-gray-600 mt-2">Searching...</p>
        </div>

        <!-- Results -->
        <div id="prospectingResults" class="hidden mt-6">
          <div class="mb-4 flex items-center justify-between">
            <div id="prospectingResultsHeader" class="text-sm text-gray-600 font-medium"></div>
            <button 
              id="exportCsvBtn"
              onclick="exportProspectingResultsToCSV()"
              class="hidden px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors text-sm font-medium">
              Export to CSV
            </button>
          </div>
          <div class="overflow-y-auto border border-gray-200 rounded-lg p-3" style="max-height: calc(100vh - 350px); min-height: 400px;">
            <div id="prospectingScroll" class="flex flex-col gap-4"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Deals Module -->
    <div id="dealsModule" class="hidden">
      <div class="module-card rounded-xl w-full p-6 space-y-4">
        <p class="text-gray-600 mt-8 mb-10 px-6 py-4">
          Here we have a list of early stage deals, including pre-seed and seed funding rounds. 
          Use the filters below to explore deals by category and funding round.
          Currently they are sorted by recency.
        </p>
        <!-- Filters -->
        <div class="space-y-3">
          <div class="flex gap-4">
            <div class="flex-1">
              <label class="block text-sm font-medium text-gray-700 mb-1">
                Filter by Category
              </label>
              <div class="relative">
                <button type="button" 
                        onclick="toggleMultiSelect('dealCategory')"
                        class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 bg-white text-left flex items-center justify-between">
                  <span id="dealCategoryDisplay">All Categories</span>
                  <span class="text-gray-400">▼</span>
                </button>
                <div id="dealCategoryDropdown" class="hidden absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                  <div class="p-2">
                    <label class="flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded">
                      <input type="checkbox" 
                             class="mr-2" 
                             onchange="toggleCategoryOption('all')"
                             id="dealCategoryAll">
                      <span>All Categories</span>
                    </label>
                    <div id="dealCategoryOptions" class="border-t border-gray-200 mt-1 pt-1">
                      <!-- Options will be populated here -->
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="flex-1">
              <label class="block text-sm font-medium text-gray-700 mb-1">
                Filter by Funding Round
              </label>
              <div class="relative">
                <button type="button" 
                        onclick="toggleMultiSelect('dealFundingRound')"
                        class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 bg-white text-left flex items-center justify-between">
                  <span id="dealFundingRoundDisplay">All Funding Rounds</span>
                  <span class="text-gray-400">▼</span>
                </button>
                <div id="dealFundingRoundDropdown" class="hidden absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                  <div class="p-2">
                    <label class="flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded">
                      <input type="checkbox" 
                             class="mr-2" 
                             onchange="toggleFundingRoundOption('all')"
                             id="dealFundingRoundAll">
                      <span>All Funding Rounds</span>
                    </label>
                    <div id="dealFundingRoundOptions" class="border-t border-gray-200 mt-1 pt-1">
                      <!-- Options will be populated here -->
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Loading indicator -->
        <div id="dealsLoading" class="hidden text-center py-4">
          <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
          <p class="text-sm text-gray-600 mt-2">Loading...</p>
        </div>

        <!-- Results -->
        <div id="dealsResults" class="hidden overflow-y-auto max-h-[700px] border border-gray-200 rounded-lg p-3">
          <div id="dealsScroll" class="flex flex-col gap-4"></div>
        </div>
      </div>
    </div>

  </main>
</body>

<script>
// Toggle sidebar on mobile
function toggleSidebar() {
  const sidebar = document.querySelector('.sidebar-container');
  const overlay = document.getElementById('sidebarOverlay');
  
  if (sidebar && overlay) {
    sidebar.classList.toggle('active');
    overlay.classList.toggle('active');
  }
}

// Close sidebar on mobile when clicking outside or selecting a module
function closeSidebarMobile() {
  if (window.innerWidth <= 768) {
    const sidebar = document.querySelector('.sidebar-container');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar && overlay) {
      sidebar.classList.remove('active');
      overlay.classList.remove('active');
    }
  }
}

function showModule(id) {
  ["welcomeModule", "valuationModule", "foundersModule", "dealsModule", "interestingPeopleModule", "tasteTreeModule", "prospectingModule"].forEach(m =>
    document.getElementById(m).classList.add("hidden")
  );
  document.getElementById(id).classList.remove("hidden");

  document.querySelectorAll(".sidebar-btn").forEach(b =>
    b.classList.remove("bg-blue-700")
  );
  document.getElementById("btn-" + id).classList.add("bg-blue-700");
  
  // Close sidebar on mobile after selecting a module
  closeSidebarMobile();

  if (id === "foundersModule") {
    loadFilters().then(() => showTab("recommended"));
  }
  
  // Load dashboard when showing home page
  if (id === "welcomeModule") {
    loadDashboardRecommendations();
    loadDashboardDeals();
  }
  
  // Load deals when showing deals module
  if (id === "dealsModule") {
    loadDealsFilters().then(() => loadDeals());
  }
  
  // Load taste tree when showing taste tree module
  if (id === "tasteTreeModule") {
    loadTasteTree();
  }
  
  // Load interesting people when showing interesting people module
  if (id === "interestingPeopleModule") {
    loadInterestingPeople();
  }
}




</script>

  <script>
    
    const API_URL = "";
    const $ = (id) => document.getElementById(id);

    // Toggle category cascade menu - defined early for button onclick
    window.toggleCategoryMenu = function() {
      const menu = document.getElementById("categoryCascadeMenu");
      if (menu) {
        menu.classList.toggle("hidden");
      }
    };

    // Toggle location cascade menu - defined early for button onclick
    window.toggleLocationMenu = function() {
      const menu = document.getElementById("locationCascadeMenu");
      if (menu) {
        menu.classList.toggle("hidden");
      }
    };

    function fmtNum(v) {
      if (v == null || isNaN(v)) return "N/A";
      if (Math.abs(v) >= 1e9) return `$${(v / 1e9).toFixed(2)}B`;
      if (Math.abs(v) >= 1e6) return `$${(v / 1e6).toFixed(2)}M`;
      if (Math.abs(v) >= 1e3) return `$${(v / 1e3).toFixed(2)}K`;
      return `$${v.toFixed(2)}`;
    }

    async function fetchData() {
        const ticker = $("tickerInput").value.trim().toUpperCase();
        if (!ticker) return showError("Enter a ticker symbol.");
        hideError(); $("results").classList.add("hidden"); $("loading").classList.remove("hidden");

        try {
            async function safeFetchJSON(url) {
            const res = await fetch(url);
            const text = await res.text();
            const cleanText = text
                .replace(/\b-?Infinity\b/g, "null") // handles Infinity and -Infinity
                .replace(/\bNaN\b/g, "null");
            return JSON.parse(cleanText);
            }

            const [finRes, incRes, priceRes, valRes] = await Promise.all([
            safeFetchJSON(`${API_URL}/api/financials/${ticker}`),
            safeFetchJSON(`${API_URL}/api/income/${ticker}`),
            safeFetchJSON(`${API_URL}/api/stock-price/${ticker}`),
            safeFetchJSON(`${API_URL}/api/valuation/${ticker}`),
            ]);

            $("loading").classList.add("hidden");

            if (!finRes.success || !priceRes.success || !valRes.success) {
            return showError("Unable to retrieve data for this ticker.");
            }

            $("companyHeader").textContent = ticker;
            $("stockPrice").textContent = priceRes.data?.price ? `$${priceRes.data.price.toFixed(2)}` : "N/A";
            $("revenue").textContent = fmtNum(finRes.data?.revenue);
            $("pe").textContent = valRes.data?.pe ? valRes.data.pe.toFixed(2) : "N/A";
            $("ps").textContent = valRes.data?.ps ? valRes.data.ps.toFixed(2) : "N/A";
            $("marketCap").textContent = fmtNum(valRes.data?.market_cap);

            if (incRes?.success) {
            window.latestIncome = incRes.data?.income_statement || null;
            window.fullFinancials = incRes.data || null;
            } else {
            window.latestIncome = null;
            window.fullFinancials = null;
            }

            $("results").classList.remove("hidden");
        } catch (err) {
            console.error(err);
            showError("Failed to connect to backend.");
            $("loading").classList.add("hidden");
        }
        }

    function showError(msg){$("errorBox").textContent=msg;$("errorBox").classList.remove("hidden");}
    function hideError(){$("errorBox").classList.add("hidden");}

    // Helper: find all period keys and sort newest → oldest
    function extractPeriods(statement) {
        return Object.keys(statement)
        .filter(k => /^\d{4}-\d{2}(-\d{2})?$/.test(k))
        .sort((a, b) => b.localeCompare(a));
    }

    // Helper: normalize a date key to YYYY-MM for mapping
    const norm = (s) => (s || "").slice(0, 7);

    // Heuristic formatting (reuses your fmtNum for currency-like values)
    function formatCell(label, v) {
        if (v === null || v === undefined || !isFinite(v)) return "N/A";
        const lower = (label || "").toLowerCase();
        if (lower.includes("earnings per share")) return v.toFixed(2);
        if (lower.includes("shares")) {
        const abs = Math.abs(v);
        if (abs >= 1e9) return (v / 1e9).toFixed(2) + "B";
        if (abs >= 1e6) return (v / 1e6).toFixed(2) + "M";
        return v.toLocaleString("en-US", { maximumFractionDigits: 0 });
        }
        return fmtNum(v); // your existing formatter
    }
    function openEmptyModal(title = "Results") {
        $("modalBody").innerHTML = "";
        $("modalOverlay").classList.remove("hidden");
        $("modal").classList.remove("hidden");
        document.querySelector("#modal h2").textContent = title;
        }

    function openModal() {
        const full = window.fullFinancials || null;
        const income = full?.income_statement || null;
        const meta = full?.filing_metadata || [];

        if (!income || !income.label) {
            $("modalBody").innerHTML =
            `<div class="p-6 text-center text-gray-500">No income data</div>`;
            $("modalOverlay").classList.remove("hidden");
            $("modal").classList.remove("hidden");
            return;
        }

        // Helpers
        const periods = Object.keys(income)
            .filter(k => /^\d{4}-\d{2}(-\d{2})?$/.test(k))
            .sort((a,b) => b.localeCompare(a)); // newest → left
        const labelsMap = income.label || {};
        const labelIdxs = Object.keys(labelsMap).sort((a,b)=>Number(a)-Number(b));
        const norm = s => (s || "").slice(0,7);
        const metaByPeriod = {};
        meta.forEach(m => metaByPeriod[norm(m.period_end)] = m);

        // Build table shell
        const body = $("modalBody");
        if (!body) { console.error("Missing #modalBody"); return; }
        body.innerHTML = `
            <div class="bg-white rounded-lg shadow-md overflow-hidden">
            <div class="px-6 py-4 bg-gray-50 border-b border-gray-200 flex items-center justify-between">
                <h3 class="text-lg font-semibold text-gray-800">Income Statement</h3>
                <div class="text-xs text-gray-500">Periods: ${periods.join(" • ")}</div>
            </div>
            <div class="overflow-x-auto">
                <table class="w-full">
                <thead class="bg-gray-100 border-b border-gray-200" id="incomeThead"></thead>
                <tbody class="divide-y divide-gray-200" id="incomeTable"></tbody>
                </table>
            </div>
            </div>
        `;

        // Header row
        const thead = $("incomeThead");
        thead.innerHTML = `
            <tr>
            <th class="px-6 py-3 text-left text-sm font-semibold text-gray-700 sticky left-0 bg-gray-100 z-10">Line Item</th>
            ${periods.map(p => {
                const m = metaByPeriod[norm(p)];
                const type = m?.type || "—";
                const pe = m?.period_end || p;
                return `
                <th class="px-6 py-3 text-right text-sm font-semibold text-gray-700">
                    <div class="flex flex-col items-end">
                    <span class="inline-block text-xs px-2 py-0.5 rounded bg-gray-200 text-gray-700">${type}</span>
                    <span class="text-xs text-gray-500 mt-1">${pe}</span>
                    </div>
                </th>`;
            }).join("")}
            </tr>
        `;

        // Body rows
        const tbody = $("incomeTable");
        labelIdxs.forEach(idx => {
            const label = labelsMap[idx];
            const tr = document.createElement("tr");
            tr.className = "hover:bg-gray-50";

            // sticky label
            const th = document.createElement("td");
            th.className = "px-6 py-3 text-sm text-gray-800 sticky left-0 bg-white z-10";
            th.textContent = label;
            tr.appendChild(th);

            // cells per period
            periods.forEach(p => {
            const rowVals = income[p] || {};
            const v = Object.prototype.hasOwnProperty.call(rowVals, idx) ? rowVals[idx] : null;
            const td = document.createElement("td");
            td.className = "px-6 py-3 text-sm text-gray-800 text-right";
            td.textContent = formatCell(label, v);
            tr.appendChild(td);
            });

            tbody.appendChild(tr);
        });

        $("modalOverlay").classList.remove("hidden");
        $("modal").classList.remove("hidden");

        // simple formatter that reuses your fmtNum for currency-like values
        function formatCell(label, v) {
            if (v === null || v === undefined || !isFinite(v)) return "N/A";
            const lower = (label || "").toLowerCase();
            if (lower.includes("earnings per share")) return Number(v).toFixed(2);
            if (lower.includes("shares")) {
            const n = Number(v);
            const abs = Math.abs(n);
            if (abs >= 1e9) return (n/1e9).toFixed(2) + "B";
            if (abs >= 1e6) return (n/1e6).toFixed(2) + "M";
            return n.toLocaleString("en-US", { maximumFractionDigits: 0 });
            }
            return fmtNum(Number(v));
        }
        }

        function closeModal() {
        $("modalOverlay").classList.add("hidden");
        $("modal").classList.add("hidden");
        }

  </script>
  <script>
  // In-memory map
  let industryMapData = null;

  // Load map on page load
  document.addEventListener("DOMContentLoaded", () => {
    loadIndustryMap();
    loadPortfolioCompanies();
    // Load dashboard on initial page load
    loadDashboardRecommendations();
    loadDashboardDeals();
  });

  async function loadIndustryMap() {
    try {
      // try API first, then fall back to static file if you serve one
      const res = await fetch(`${API_URL || ""}/api/industry-map`);
      const json = await res.json();
      if (!json.success || !json.data) throw new Error("bad payload");

      industryMapData = json.data; // expects shape { industries: { [industry]: { sectors: { [sector]: { industry_groups: { [group]: [tickers] } } } } } }
      populateIndustryDropdown();
    } catch (e) {
      console.error("industry map load failed", e);
      showError("Failed to load industry map.");
    }
  }

  async function loadPortfolioCompanies() {
    try {
      const res = await fetch(`${API_URL || ""}/api/portfolio-companies`);
      const json = await res.json();
      if (!json.success || !json.data) return;
      const select = document.getElementById("portfolioCompanySelect");
      if (!select) return;
      select.innerHTML = `<option value="">Select portfolio company</option>`;
      for (const c of json.data) {
        const opt = document.createElement("option");
        opt.value = c.id;
        opt.textContent = c.company_name || c.id;
        select.appendChild(opt);
      }
    } catch (e) {
      console.error("portfolio companies load failed", e);
    }
  }

  function populateIndustryDropdown() {
    const industrySelect = $("industrySelect");
    industrySelect.innerHTML = `<option value="">Select Industry</option>`;
    const industries = Object.keys(industryMapData.industries || {}).sort();
    for (const name of industries) {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      industrySelect.appendChild(opt);
    }
    // reset dependents
    const sectorSelect = $("sectorSelect");
    const groupSelect = $("industryGroupSelect");
    sectorSelect.disabled = true;
    groupSelect.disabled = true;
    groupSelect.classList.add("bg-gray-100");
  }

  function updateSectorOptions() {
    const industry = $("industrySelect").value;
    const sectorSelect = $("sectorSelect");
    const groupSelect = $("industryGroupSelect");

    // reset
    sectorSelect.innerHTML = `<option value="">Select Sector</option>`;
    groupSelect.innerHTML = `<option value="">All Groups in Sector</option>`;
    groupSelect.disabled = true;
    groupSelect.classList.add("bg-gray-100");

    if (!industry) {
      sectorSelect.disabled = true;
      return;
    }
    sectorSelect.disabled = false;

    const sectors = Object.keys(industryMapData.industries[industry].sectors || {}).sort();
    for (const s of sectors) {
      const opt = document.createElement("option");
      opt.value = s;
      opt.textContent = s;
      sectorSelect.appendChild(opt);
    }
  }

  function updateIndustryGroupOptions() {
    const industry = $("industrySelect").value;
    const sector = $("sectorSelect").value;
    const groupSelect = $("industryGroupSelect");

    groupSelect.innerHTML = `<option value="">All Groups in Sector</option>`;

    if (!sector) {
      groupSelect.disabled = true;
      groupSelect.classList.add("bg-gray-100");
      return;
    }
    groupSelect.disabled = false;
    groupSelect.classList.remove("bg-gray-100");

    const groups = Object.keys(
      industryMapData.industries[industry].sectors[sector].industry_groups || {}
    ).sort();

    for (const g of groups) {
      const opt = document.createElement("option");
      opt.value = g;
      opt.textContent = g;
      groupSelect.appendChild(opt);
    }
  }

async function streamAndRenderComps(tickers, title) {
  openEmptyModal(title);
  $("modalBody").innerHTML = `<p class="text-gray-600 p-4">Loading ${tickers.length} companies...</p>`;

  let resp;
  try {
    resp = await fetch(`${API_URL}/api/industry-comparison-stream`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tickers }),
    });
  } catch (e) {
    $("modalBody").innerHTML = `<p class="text-red-600 p-4">Failed to connect: ${e.message}</p>`;
    return;
  }

  if (!resp.ok) {
    const errText = await resp.text();
    $("modalBody").innerHTML = `<p class="text-red-600 p-4">Server error (${resp.status}): ${errText.slice(0, 200)}</p>`;
    return;
  }

  const reader = resp.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";

  $("modalBody").innerHTML = `
    <div class="overflow-x-auto">
      <table id="comparisonTable" class="min-w-full border border-gray-200 text-sm text-gray-800">
        <thead class="bg-gray-100 text-gray-700 font-semibold">
          <tr>
            <th class="text-left px-4 py-2">Ticker</th>
            <th class="text-left px-4 py-2">Company</th>
            <th class="text-right px-4 py-2">Revenue</th>
            <th class="text-right px-4 py-2">P/E</th>
            <th class="text-right px-4 py-2">P/S</th>
            <th class="text-right px-4 py-2">Market Cap</th>
          </tr>
        </thead>
        <tbody id="comparisonTableBody"></tbody>
      </table>
    </div>
  `;

  const tbody = $("comparisonTableBody");
  const missing = [];
  const validRows = [];

  while (true) {
    const { done, value } = await reader.read();
    if (value) buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split("\n");
    buffer = done ? "" : lines.pop();

    for (const line of lines) {
      if (!line.trim()) continue;
      let msg;
      try {
        msg = JSON.parse(line);
      } catch (e) {
        console.warn("Stream parse error:", line.slice(0, 80), e);
        continue;
      }

      if (msg.type === "company") {
        const c = msg.data;
        validRows.push(c);
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="px-4 py-2 text-blue-600">${c.ticker}</td>
          <td class="px-4 py-2 text-gray-700">${c.company_name || "—"}</td>
          <td class="px-4 py-2 text-right">${fmtNum(c.revenue)}</td>
          <td class="px-4 py-2 text-right">${c.pe?.toFixed(2) ?? "N/A"}</td>
          <td class="px-4 py-2 text-right">${c.ps?.toFixed(2) ?? "N/A"}</td>
          <td class="px-4 py-2 text-right">${fmtNum(c.market_cap)}</td>`;
        tbody.appendChild(tr);
      }

      if (msg.type === "skip") missing.push(msg.ticker);
      if (msg.type === "error" && msg.ticker) missing.push(msg.ticker);
    }
    if (done) break;
  }

  if (validRows.length) {
    const avg = (key) =>
      validRows.reduce((a, b) => a + (Number(b[key]) || 0), 0) / validRows.length;

    const tr = document.createElement("tr");
    tr.className = "bg-gray-100 font-semibold border-t";
    tr.innerHTML = `
    <td class="px-4 py-2 text-gray-700" colspan="2">Average (${validRows.length})</td>
    <td class="px-4 py-2 text-right">${fmtNum(avg("revenue"))}</td>
    <td class="px-4 py-2 text-right">${avg("pe").toFixed(2)}</td>
    <td class="px-4 py-2 text-right">${avg("ps").toFixed(2)}</td>
    <td class="px-4 py-2 text-right">${fmtNum(avg("market_cap"))}</td>`;
    tbody.appendChild(tr);
  }

  if (missing.length) {
    const missHeader = document.createElement("tr");
    missHeader.innerHTML = `<td colspan="6" class="pt-6 pb-2 font-bold text-gray-700">Tickers with missing data</td>`;
    tbody.appendChild(missHeader);

    for (const t of missing) {
      const tr = document.createElement("tr");
      tr.className = "text-gray-400 italic";
      tr.innerHTML = `
        <td class="px-4 py-2">${t}</td>
        <td class="px-4 py-2 text-right" colspan="5">No data available</td>`;
      tbody.appendChild(tr);
    }
  }

  if (validRows.length === 0 && missing.length === 0) {
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="6" class="px-4 py-6 text-gray-500 text-center">No data received. Check the console for errors.</td>`;
    tbody.appendChild(tr);
  }
}

async function fetchIndustryComparison() {
  const industry = $("industrySelect").value;
  const sector = $("sectorSelect").value;
  const group = $("industryGroupSelect").value;
  if (!industry || !sector) {
    showError("Please select at least an industry and sector");
    return;
  }

  const path = `${industry}/${sector}/${group || ""}`.replace(/\/$/, "");
  const tickersRes = await fetch(`${API_URL}/api/industry-tickers/${path}`);
  const tickersJson = await tickersRes.json();
  const tickers = tickersJson?.data?.tickers || [];
  if (!tickers.length) {
    showError("No tickers found");
    return;
  }

  await streamAndRenderComps(tickers, "Industry Comparison");
}

async function fetchVerticalComps() {
  const vertical = (document.getElementById("verticalInput")?.value || "").trim();
  const portfolioId = document.getElementById("portfolioCompanySelect")?.value || "";

  if (vertical && portfolioId) {
    showError("Please use either vertical or portfolio company, not both.");
    return;
  }
  if (!vertical && !portfolioId) {
    showError("Please enter a vertical or select a portfolio company.");
    return;
  }

  let tickers = [];
  if (portfolioId) {
    const res = await fetch(`${API_URL}/api/portfolio-companies/${portfolioId}/tickers`);
    const json = await res.json();
    if (!json.success) {
      showError(json.error || "Failed to load portfolio tickers");
      return;
    }
    tickers = json.data?.tickers || [];
    if (!tickers.length) {
      showError("No comps configured for this portfolio company.");
      return;
    }
  } else {
    const res = await fetch(`${API_URL}/api/vertical-tickers`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ vertical }),
    });
    const json = await res.json();
    if (!json.success) {
      showError(json.error || "Failed to find relevant tickers");
      return;
    }
    tickers = json.data?.tickers || [];
    if (!tickers.length) {
      showError("No relevant tickers found for this vertical.");
      return;
    }
  }

  const title = portfolioId ? "Portfolio Comps" : `Vertical: ${vertical}`;
  await streamAndRenderComps(tickers, title);
}


</script>
<script>
  const API_KEY = "5f8e7ac4f6f8a3b6b2d91c66e01d0f7d1a91f4f4bfc1f3263e57b85c14f6a733";

const FOUNDERS_API = "https://monty-api-production.up.railway.app";
const CONTACT_STATUS_ENDPOINT = "/api/founders/contact-status";
const contactStatusCache = new Map();

// Lazy loading manager for contact status
const contactStatusLazyLoader = {
  observer: null,
  pendingIds: new Set(),
  pendingTimeout: null,
  cardData: new Map(), // Maps entryId -> {card, row}
  
  init() {
    // Load cache from localStorage on init
    this.loadCacheFromStorage();
    
    // Create Intersection Observer for lazy loading
    this.observer = new IntersectionObserver((entries) => {
      const visibleIds = [];
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const entryId = entry.target.getAttribute('data-entry-id');
          if (entryId && !contactStatusCache.has(entryId)) {
            visibleIds.push(entryId);
            this.pendingIds.add(entryId);
          }
        }
      });
      
      // Batch fetch visible cards (debounce to avoid too many requests)
      if (visibleIds.length > 0) {
        clearTimeout(this.pendingTimeout);
        this.pendingTimeout = setTimeout(() => {
          this.fetchPending();
        }, 100); // Wait 100ms to batch multiple visible cards
      }
    }, {
      root: null,
      rootMargin: '100px', // Start loading 100px before card is visible
      threshold: 0.1
    });
  },
  
  // Load cache from localStorage
  loadCacheFromStorage() {
    try {
      const cached = localStorage.getItem('contactStatusCache');
      if (cached) {
        const data = JSON.parse(cached);
        const now = Date.now();
        // Cache expires after 24 hours
        const CACHE_EXPIRY = 24 * 60 * 60 * 1000;
        
        Object.entries(data).forEach(([key, value]) => {
          if (value.timestamp && (now - value.timestamp) < CACHE_EXPIRY) {
            contactStatusCache.set(key, value.data);
          }
        });
      }
    } catch (err) {
      console.error("Failed to load contact status cache from storage", err);
    }
  },
  
  // Save cache to localStorage
  saveCacheToStorage() {
    try {
      const data = {};
      contactStatusCache.forEach((value, key) => {
        data[key] = {
          data: value,
          timestamp: Date.now()
        };
      });
      localStorage.setItem('contactStatusCache', JSON.stringify(data));
    } catch (err) {
      console.error("Failed to save contact status cache to storage", err);
    }
  },
  
  // Register a card for lazy loading
  observeCard(card, entryId, row) {
    if (entryId) {
      card.setAttribute('data-entry-id', entryId);
      this.cardData.set(entryId, { card, row });
      
      // If already cached, update immediately
      if (contactStatusCache.has(entryId)) {
        this.updateCard(entryId, contactStatusCache.get(entryId));
      } else {
        // Observe for lazy loading
        this.observer.observe(card);
      }
    }
  },
  
  // Fetch pending contact statuses
  async fetchPending() {
    if (this.pendingIds.size === 0) return;
    
    const idsToFetch = Array.from(this.pendingIds);
    this.pendingIds.clear();
    
    // Filter out already cached
    const uncached = idsToFetch.filter(id => !contactStatusCache.has(id));
    if (uncached.length === 0) {
      // All were cached, update cards
      idsToFetch.forEach(id => {
        if (contactStatusCache.has(id)) {
          this.updateCard(id, contactStatusCache.get(id));
        }
      });
      return;
    }
    
    try {
      const res = await fetch(CONTACT_STATUS_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ids: uncached })
      });
      
      if (res.ok) {
        const json = await res.json();
        if (json.success && json.data) {
          Object.entries(json.data).forEach(([key, value]) => {
            const normalizedKey = normalizeEntryId(key);
            if (normalizedKey) {
              contactStatusCache.set(normalizedKey, value);
              if (normalizedKey !== key) {
                contactStatusCache.set(key, value);
              }
              if (value && typeof value === 'object') {
                value.entry_id = normalizedKey;
              }
              // Update card if it exists
              this.updateCard(normalizedKey, value);
            }
          });
          
          // Save to localStorage
          this.saveCacheToStorage();
        }
      }
    } catch (err) {
      console.error("Error fetching pending contact status", err);
    }
  },
  
  // Update a card with contact status
  updateCard(entryId, status) {
    const cardInfo = this.cardData.get(entryId);
    if (!cardInfo) return;
    
    const { card, row } = cardInfo;
    const contactStatusMap = { [entryId]: status };
    
    // Store the click handler before replacing innerHTML
    const clickHandler = () => {
      // Check if this is a dashboard card (has showModule in click handler)
      const currentClick = card.onclick;
      if (card.getAttribute('data-dashboard-card') === 'true') {
        showModule('foundersModule');
        setTimeout(() => openFounderModal(row), 100);
      } else {
        openFounderModal(row);
      }
    };
    
    // Re-render card with contact status
    card.innerHTML = createFounderCardHTML(row, contactStatusMap);
    attachContactStatusHandlers(card, row);
    card.addEventListener("click", clickHandler);
    
    // Stop observing since we've loaded the status
    this.observer.unobserve(card);
  },
  
  // Clean up observer for a card
  unobserveCard(card) {
    this.observer.unobserve(card);
    const entryId = card.getAttribute('data-entry-id');
    if (entryId) {
      this.cardData.delete(entryId);
    }
  },
  
  // Clean up all observers
  disconnect() {
    if (this.observer) {
      this.observer.disconnect();
    }
    this.cardData.clear();
    this.pendingIds.clear();
  }
};

// Initialize lazy loader on page load
if (typeof IntersectionObserver !== 'undefined') {
  contactStatusLazyLoader.init();
}

function resolveEntryId(row) {
  /**
   * Resolve the entry ID for a founder row.
   * IMPORTANT: The database entry_id column stores profile_url, so we prioritize profile_url.
   * This ensures consistency between what we store and what we look up.
   */
  const candidates = [
    row.profile_url,  // Prioritize profile_url since that's what's stored in DB entry_id column
    row.entry_id,     // Check entry_id if explicitly set (though DB uses profile_url)
    row.id,
    row.uuid,
    row.company_uuid,
    row.company_id,
    row.company_name
  ];

  for (const value of candidates) {
    if (value === null || value === undefined) continue;
    const str = String(value).trim();
    if (str) {
      return str;
    }
  }

  return null;
}

function normalizeEntryId(entryId) {
  if (!entryId) return null;
  let normalized = String(entryId).trim();
  
  // Normalize LinkedIn URLs to a consistent format
  // Remove protocol (http://, https://) and www. prefix
  // Convert to lowercase for domain part, but preserve the path
  if (normalized.includes('linkedin.com')) {
    // Remove protocol
    normalized = normalized.replace(/^https?:\/\//i, '');
    // Remove www. if present
    normalized = normalized.replace(/^www\./i, '');
    // Ensure it starts with linkedin.com (lowercase domain)
    if (normalized.toLowerCase().startsWith('linkedin.com')) {
      normalized = 'linkedin.com' + normalized.substring('linkedin.com'.length);
    }
  }
  
  return normalized;
}

async function fetchContactStatuses(entryIds) {
  // Normalize entry IDs to ensure consistent matching
  const ids = Array.from(new Set(entryIds.filter(Boolean).map(normalizeEntryId)));
  if (!ids.length) return {};

  // Initialize result object with cached values
  const result = {};
  ids.forEach(id => {
    if (contactStatusCache.has(id)) {
      result[id] = contactStatusCache.get(id);
    }
  });

  const uncached = ids.filter(id => !contactStatusCache.has(id));
  
  // If all are cached, return immediately
  if (!uncached.length) {
    return result;
  }

  // Use POST to send all IDs in request body (avoids URL length issues)
  // Backend handles batching internally, so we can send all at once
  try {
    const res = await fetch(CONTACT_STATUS_ENDPOINT, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ ids: uncached })
    });

    if (res.ok) {
      const json = await res.json();
      if (json.success && json.data) {
        // Normalize entry IDs from API response and cache them
        Object.entries(json.data).forEach(([key, value]) => {
          const normalizedKey = normalizeEntryId(key);
          if (normalizedKey) {
            contactStatusCache.set(normalizedKey, value);
            result[normalizedKey] = value;
            // Also store with original key if different (for fallback lookups)
            if (normalizedKey !== key) {
              contactStatusCache.set(key, value);
            }
            // Also update the entry_id in the value to be normalized for consistency
            if (value && typeof value === 'object') {
              value.entry_id = normalizedKey;
            }
          }
        });
        
        // Save to localStorage after fetching
        contactStatusLazyLoader.saveCacheToStorage();
      }
    } else {
      const errorText = await res.text();
      console.error("Failed to fetch contact status", res.status, res.statusText);
    }
  } catch (err) {
    console.error("Error fetching contact status", err);
  }

  return result;
}

async function persistFounderStatus(entryId, updates = {}) {
  const normalizedId = normalizeEntryId(entryId);
  if (!normalizedId) {
    throw new Error("Invalid entry ID");
  }
  const payload = { ...updates };
  const res = await fetch(`${CONTACT_STATUS_ENDPOINT}/${encodeURIComponent(normalizedId)}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });

  if (!res.ok) {
    throw new Error(`Failed to update founder status: ${res.status} ${res.statusText}`);
  }

  const json = await res.json();
  if (!json.success) {
    throw new Error(json.error || "Unknown error while updating founder status");
  }

  const record = json.data || { entry_id: normalizedId, ...updates };
  contactStatusCache.set(normalizedId, record);
  // Save to localStorage
  contactStatusLazyLoader.saveCacheToStorage();
  return record;
}

function formatContactedTimestamp(value) {
  if (!value) return "";
  try {
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return "";
    return date.toLocaleDateString(undefined, { month: "short", day: "numeric", year: "numeric" });
  } catch (err) {
    console.warn("Failed to format contacted timestamp", err);
    return "";
  }
}

function syncFounderStatusUI(card, record) {
  if (!card || !record) return;

  const toggles = card.querySelectorAll("input.founder-status-toggle");
  toggles.forEach(toggle => {
    const statusType = toggle.dataset.statusType;
    if (!statusType) return;
    // Explicitly check if the statusType exists in record (even if it's false)
    if (statusType in record) {
      const value = record[statusType];
      toggle.checked = value === true || value === "true" || value === 1;
    }
  });

  const metas = card.querySelectorAll(".status-meta");
  metas.forEach(meta => {
    const statusType = meta.dataset.statusType;
    if (!statusType) return;
    const isActive = Boolean(record[statusType]);
    const timestampKey = `${statusType}_at`;
    const formatted = isActive ? formatContactedTimestamp(record[timestampKey]) : "";
    if (formatted) {
      meta.textContent = `Updated ${formatted}`;
      meta.classList.remove("hidden");
    } else {
      meta.textContent = "";
      meta.classList.add("hidden");
    }
  });
}

function attachContactStatusHandlers(card, row) {
  const toggles = card.querySelectorAll("input.founder-status-toggle");
  if (!toggles.length) return;

  toggles.forEach(toggle => {
    toggle.addEventListener("click", event => event.stopPropagation());
    toggle.addEventListener("change", async event => {
      event.stopPropagation();

      const encodedId = toggle.dataset.entryId || "";
      const entryId = normalizeEntryId(encodedId ? decodeURIComponent(encodedId) : resolveEntryId(row));
      const statusType = toggle.dataset.statusType;

      if (!entryId || !statusType) return;

      const nextValue = toggle.checked;
      toggle.disabled = true;

      try {
        const record = await persistFounderStatus(entryId, { [statusType]: nextValue });
        syncFounderStatusUI(card, record);
      } catch (err) {
        console.error("Failed to persist founder status", err);
        toggle.checked = !nextValue;
        alert("Failed to update status. Please try again.");
      } finally {
        toggle.disabled = false;
      }
    });
  });
}

function getAccessDateTimestamp(row) {
  if (!row || !row.access_date) return Number.NEGATIVE_INFINITY;
  const timestamp = new Date(row.access_date).getTime();
  return Number.isFinite(timestamp) ? timestamp : Number.NEGATIVE_INFINITY;
}

function sortFoundersByAccessDateDesc(rows) {
  if (!Array.isArray(rows)) return [];
  return [...rows].sort((a, b) => getAccessDateTimestamp(b) - getAccessDateTimestamp(a));
}

function getFounderCompanyKey(row) {
  if (!row) return "";
  const companyName = clean(row.company_name || row.Company_Name || row.company || row.Company || "");
  return companyName.toLowerCase();
}

function dedupeFoundersByCompany(rows) {
  if (!Array.isArray(rows)) return [];
  const seen = new Set();
  const deduped = [];

  for (const row of rows) {
    const companyKey = getFounderCompanyKey(row);
    if (!companyKey) {
      deduped.push(row);
      continue;
    }
    if (seen.has(companyKey)) continue;
    seen.add(companyKey);
    deduped.push(row);
  }

  return deduped;
}

async function loadFounders(endpoint) {
  $("foundersLoading").classList.remove("hidden");
  $("foundersResults").classList.add("hidden");
  $("foundersScroll").innerHTML = "";

  try {
    // fetch the data first
    const res = await fetch(`${FOUNDERS_API}/${endpoint}`, {
      headers: {
        "x-api-key": "5f8e7ac4f6f8a3b6b2d91c66e01d0f7d1a91f4f4bfc1f3263e57b85c14f6a733"
      }
    });
    const json = await res.json();
    const data = sortFoundersByAccessDateDesc(json.data || []);

    $("foundersLoading").classList.add("hidden");
    $("foundersResults").classList.remove("hidden");

    if (!data.length) {
      $("foundersScroll").innerHTML = `<p class="text-gray-500 px-4">No data found.</p>`;
      return;
    }

    const entryIds = data.map(resolveEntryId).filter(Boolean);
    let contactStatusMap = {};
    try {
      contactStatusMap = await fetchContactStatuses(entryIds);
    } catch (err) {
      console.error("Unable to load contact status", err);
    }

    const scroll = $("foundersScroll");
    for (const row of data.slice(0, 50)) {
      const card = document.createElement("div");
      card.className =
        "min-w-[250px] bg-gray-50 border border-gray-200 rounded-lg p-4 hover:shadow-md cursor-pointer flex flex-col justify-between";
      card.innerHTML = createFounderCardHTML(row, contactStatusMap);
      attachContactStatusHandlers(card, row);
      card.addEventListener("click", () => openFounderModal(row));
      scroll.appendChild(card);
    }

  } catch (err) {
    $("foundersLoading").classList.add("hidden");
    console.error(err);
    $("foundersScroll").innerHTML = `<p class="text-red-500 px-4">Error loading data.</p>`;
  }
}
function clean(value) {
  if (value === null || value === undefined) return "";
  if (typeof value === "number" && isNaN(value)) return "";
  const str = String(value).trim();
  if (!str || str.toLowerCase() === "nan" || str.toLowerCase() === "none") return "";
  return str;
}

function ensureExternalUrl(url) {
  if (!url) return null;
  const trimmed = String(url).trim();
  if (!trimmed) return null;
  if (/^https?:\/\//i.test(trimmed)) return trimmed;
  return `https://${trimmed.replace(/^\/+/, "")}`;
}


function openFounderModal(data) {
  const panel = $("founderDetailPanel");
  const title = $("founderDetailTitle");
  const body = $("founderDetailBody");

  title.textContent = clean(data.company_name) || "Founder Details";

  // Build tags section
  const tags = [];
  
  // Repeat Founder tag (only if true)
  if (data.repeat_founder === true || data.repeat_founder === "true" || String(data.repeat_founder).toLowerCase() === "true") {
    tags.push('<span class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full">Repeat Founder</span>');
  }
  
  // Technical tag (only if true)
  if (data.technical === true || data.technical === "true" || String(data.technical).toLowerCase() === "true") {
    tags.push('<span class="text-xs bg-purple-100 text-purple-700 px-2 py-1 rounded-full">Technical</span>');
  }
  
  // Tree Thesis tag (only if it exists and is not "No specific thesis on this space")
  const treeThesis = clean(data.tree_thesis);
  if (treeThesis && treeThesis.toLowerCase() !== "no specific thesis on this space") {
    tags.push(`<span class="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full">${treeThesis}</span>`);
  }

  let html = `<div class="space-y-3 text-sm text-gray-700">`;

  // Tags section at the top
  if (tags.length > 0) {
    html += `<div class="flex flex-wrap gap-2 mb-4 pb-3 border-b border-gray-200">${tags.join("")}</div>`;
  }

  // Main fields (excluding those we're handling differently)
  const fields = [
    ["Founder", data.name],
    ["Company", data.company_name],
    ["Product", data.product],
    ["Location", data.location],
    ["History", data.history],
    ["Building Since", data.building_since],
    ["Business Stage", data.business_stage],
    ["Market", data.market],
    ["Funding", data.funding],
    ["Source", data.source],
    ["Industry Expertise Score", data.industry_expertise_score],
    ["Past Success Indication Score", data.past_success_indication_score],
    ["Company Tech Score", data.company_tech_score],
  ];

  // Add only non-empty fields
  for (const [label, value] of fields) {
    const cleaned = clean(value);
    if (cleaned) html += `<p><strong>${label}:</strong> ${cleaned}</p>`;
  }

  // Helper function to parse and display tags
  function parseTags(value) {
    if (!value) return [];
    if (Array.isArray(value)) return value.filter(Boolean);
    if (typeof value === 'string') {
      return value.split(',').map(t => t.trim()).filter(t => t && t.toLowerCase() !== 'none');
    }
    return [];
  }

  // Verticals section
  const verticals = parseTags(data.verticals);
  if (verticals.length > 0) {
    html += `<div class="mt-3"><strong class="text-gray-700">Verticals:</strong><div class="flex flex-wrap gap-2 mt-2">`;
    verticals.forEach(v => {
      // Remove parentheses and their contents (e.g., "Retail Technology (high)" -> "Retail Technology")
      const cleaned = v.replace(/\s*\([^)]*\)\s*/g, '').trim();
      html += `<span class="text-xs bg-orange-100 text-orange-700 px-2 py-1 rounded-full">${cleaned}</span>`;
    });
    html += `</div></div>`;
  }

  // School Tags section
  const schoolTags = parseTags(data.school_tags);
  if (schoolTags.length > 0) {
    html += `<div class="mt-3"><strong class="text-gray-700">School Tags:</strong><div class="flex flex-wrap gap-2 mt-2">`;
    schoolTags.forEach(tag => {
      html += `<span class="text-xs bg-amber-100 text-amber-700 px-2 py-1 rounded-full">${tag}</span>`;
    });
    html += `</div></div>`;
  }

  // Company Tags section
  const companyTags = parseTags(data.company_tags);
  if (companyTags.length > 0) {
    html += `<div class="mt-3"><strong class="text-gray-700">Tags:</strong><div class="flex flex-wrap gap-2 mt-2">`;
    companyTags.forEach(tag => {
      html += `<span class="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded-full">${tag}</span>`;
    });
    html += `</div></div>`;
  }

  // Headcount (only if not 0)
  const headcount = data.headcount;
  if (headcount && headcount !== 0 && headcount !== "0") {
    html += `<p><strong>Headcount:</strong> ${headcount}</p>`;
  }

  // Optional sections
  // Links section
  const links = [];
  const profileUrl = ensureExternalUrl(data.profile_url);
  if (profileUrl)
    links.push(`<a href="${profileUrl}" target="_blank" class="text-blue-600 underline hover:text-blue-800">LinkedIn Profile</a>`);
  
  const companyWebsite = ensureExternalUrl(data.company_website);
  if (companyWebsite)
    links.push(`<a href="${companyWebsite}" target="_blank" class="text-blue-600 underline hover:text-blue-800">Company Website</a>`);
  
  const twitterUrl = ensureExternalUrl(data.twitter);
  if (twitterUrl)
    links.push(`<a href="${twitterUrl}" target="_blank" class="text-blue-600 underline hover:text-blue-800">Twitter</a>`);

  if (links.length > 0) {
    html += `<div class="mt-4 pt-3 border-t border-gray-200 flex flex-wrap gap-3">${links.join("")}</div>`;
  }

  html += `</div>`;
  body.innerHTML = html;

  panel.classList.remove("hidden");
}

function toggleSearchPanel() {
  const panel = $("searchPanel");
  panel.classList.toggle("hidden");
}

// Search and reuse loadFounders-style rendering
async function searchFounders() {
  // clear previous
  $("foundersLoading").classList.remove("hidden");
  $("searchResults").classList.add("hidden");
  $("recommendedResults").classList.add("hidden"); // Hide recommended results when searching
  $("searchScroll").innerHTML = "";

  const keyword = $("searchKeyword").value.trim();
  const tag = $("searchTag")?.value.trim() || "";

  // Ensure selectedLocations is up-to-date before searching
  populateSelectedLocations();

  // Build query using URLSearchParams for proper encoding
  // URLSearchParams handles multiple values with the same key correctly
  const query = new URLSearchParams();
  
  if (keyword) {
    query.append("keyword", keyword);
  }
  
  // Add location filters - send country/state info instead of all individual locations
  // to avoid URL length issues (76K+ characters when sending all locations)
  if (selectedCountries.size > 0) {
    selectedCountries.forEach(country => {
      const states = selectedStates.get(country) || new Set();
      
      if (states.size === 0) {
        // Country selected but no states - send country as location filter
        // The API should match locations containing this country
        query.append("location", country);
      } else {
        // States selected - send state + country combinations
        states.forEach(state => {
          if (state === '_no_state') {
            // For locations with no state, just send the country
            query.append("location", country);
          } else {
            // Send "State, Country" format for the API to match
            query.append("location", `${state}, ${country}`);
          }
        });
      }
    });
  }
  
  // Fallback: if we have selectedLocations but no country/state selections,
  // limit to first 100 to avoid URL length issues
  if (selectedLocations.size > 0 && selectedCountries.size === 0) {
    const locations = Array.from(selectedLocations).filter(Boolean).slice(0, 100);
    locations.forEach(loc => {
      query.append("location", loc);
    });
    if (selectedLocations.size > 100) {
      console.warn(`Too many locations selected (${selectedLocations.size}). Only sending first 100.`);
    }
  }
  
  // Add multiple tree path prefixes - URLSearchParams handles encoding automatically
  const treePathPrefixes = getSearchSelectedTreePaths();
  if (treePathPrefixes.length > 0) {
    treePathPrefixes.forEach(prefix => {
      if (prefix) query.append("tree_path_prefix", prefix);
    });
  }
  
  if (tag) {
    query.append("tag", tag);
  }
  
  const queryString = query.toString();
  
  // Debug: log the query parameters
  console.log("=== SEARCH DEBUG ===");
  console.log("Selected countries:", Array.from(selectedCountries));
  console.log("Selected states:", Object.fromEntries(selectedStates));
  console.log("Selected locations:", Array.from(selectedLocations));
  console.log("Selected top levels:", Array.from(selectedTopLevels));
  console.log("Selected subcategories:", Object.fromEntries(
    Array.from(selectedSubcategories.entries()).map(([k, v]) => [k, Array.from(v)])
  ));
  console.log("Tree path prefixes:", treePathPrefixes);
  console.log("Query string:", queryString);
  const fullUrl = queryString ? `${FOUNDERS_API}/search?${queryString}` : `${FOUNDERS_API}/search`;
  console.log("Full API URL:", fullUrl);
  console.log("URL length:", fullUrl.length);
  console.log("===================");

  try {
    const url = queryString ? `${FOUNDERS_API}/search?${queryString}` : `${FOUNDERS_API}/search`;
    
    // Check URL length (HTTP2 has limits, typically 8KB for headers)
    if (url.length > 8000) {
      console.error("URL too long:", url.length, "characters");
      throw new Error("Search query is too long. Please reduce the number of filters.");
    }
    
    const res = await fetch(url, {
      headers: { "x-api-key": API_KEY }
    });
    
    // Check response status before parsing JSON
    if (!res.ok) {
      const errorText = await res.text();
      console.error("API Error Response:", res.status, res.statusText, errorText);
      throw new Error(`Search failed: ${res.status} ${res.statusText}`);
    }
    
    const json = await res.json().catch(err => {
      console.error("Failed to parse JSON response:", err);
      throw new Error("Invalid response from server");
    });
    
    const data = sortFoundersByAccessDateDesc(json.data || []);

    $("foundersLoading").classList.add("hidden");

    if (!data.length) {
      $("searchResults").classList.remove("hidden");
      $("searchScroll").innerHTML = `<p class="text-gray-500 px-4">No results found.</p>`;
      return;
    }

    // Show results immediately, lazy load contact status for visible cards
    const scroll = $("searchScroll");
    
    for (const row of data.slice(0, 50)) {
      const card = document.createElement("div");
      card.className = "bg-gray-50 border border-gray-200 rounded-lg p-4 hover:shadow-md cursor-pointer transition-shadow";
      const entryId = normalizeEntryId(resolveEntryId(row));
      
      // Show without contact status first (will load lazily when visible)
      card.innerHTML = createFounderCardHTML(row, {});
      attachContactStatusHandlers(card, row);
      card.addEventListener("click", () => openFounderModal(row));
      scroll.appendChild(card);
      
      // Register for lazy loading
      if (contactStatusLazyLoader.observer) {
        contactStatusLazyLoader.observeCard(card, entryId, row);
      }
    }

    // Ensure recommended results are hidden and search results are shown
    $("recommendedResults").classList.add("hidden");
    $("searchResults").classList.remove("hidden");
  } catch (err) {
    console.error(err);
    $("foundersLoading").classList.add("hidden");
    // Ensure recommended results are hidden even on error
    $("recommendedResults").classList.add("hidden");
    $("searchResults").classList.remove("hidden");
    $("searchScroll").innerHTML = `<p class="text-red-500 px-4">Search failed.</p>`;
  }
}

function populateSelect(selectEl, items) {
  if (!selectEl) return;
  // Only append if we're still at the initial "All ..." option
  if (selectEl.options.length > 1) return;

  const uniqueSorted = [...new Set(items.filter(Boolean))]
    .sort((a, b) => a.localeCompare(b));

  const frag = document.createDocumentFragment();
  for (const v of uniqueSorted) {
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    frag.appendChild(opt);
  }
  selectEl.appendChild(frag);
}
function expandTreePrefixes(treePaths) {
  const prefixes = new Set();
  for (const path of treePaths) {
    const parts = path.split(" > ");
    for (let i = 1; i <= parts.length; i++) {
      prefixes.add(parts.slice(0, i).join(" > "));
    }
  }
  return Array.from(prefixes).sort();
}

// Parse location string and extract country and state
function parseLocation(locationString) {
  if (!locationString || typeof locationString !== 'string') {
    return { country: null, state: null, original: locationString };
  }
  
  const parts = locationString.split(',').map(p => p.trim()).filter(p => p);
  
  if (parts.length === 0) {
    return { country: null, state: null, original: locationString };
  }
  
  if (parts.length === 1) {
    // No commas, just return the single value
    return { country: parts[0], state: null, original: locationString };
  }
  
  // Use last two parts: country (last) and state (second to last)
  const country = parts[parts.length - 1];
  const state = parts[parts.length - 2];
  
  return { country, state, original: locationString };
}

// Build location hierarchy from location strings
function buildLocationHierarchy(locations) {
  const hierarchy = {};
  
  locations.filter(Boolean).forEach(loc => {
    const { country, state, original } = parseLocation(loc);
    
    if (!country) {
      // Skip invalid locations
      return;
    }
    
    if (!hierarchy[country]) {
      hierarchy[country] = {};
    }
    
    if (state) {
      if (!hierarchy[country][state]) {
        hierarchy[country][state] = new Set();
      }
      hierarchy[country][state].add(original);
    } else {
      // No state, store directly under country
      if (!hierarchy[country]['_no_state']) {
        hierarchy[country]['_no_state'] = new Set();
      }
      hierarchy[country]['_no_state'].add(original);
    }
  });
  
  return hierarchy;
}

async function loadFilters() {
  try {
    const res = await fetch(`${FOUNDERS_API}/filters`, {
      headers: { "x-api-key": API_KEY }
    });
    const json = await res.json();
    const locations = json.locations || [];
    const treePaths = json.tree_paths || [];

    // Build location hierarchy
    locationHierarchy = buildLocationHierarchy(locations);
    
    // Populate country options
    populateLocationCountries();

    buildTreeHierarchy(treePaths);
    populateTreeLevel1(); // for recommended
    populateSearchTreeLevel1(); // for search
  } catch (e) {
    console.error("Failed to load filters", e);
  }
}

// Populate country options in the cascading menu
function populateLocationCountries() {
  const countryOptions = $("locationCountryOptions");
  if (!countryOptions) return;
  
  countryOptions.innerHTML = "";
  
  const countries = Object.keys(locationHierarchy).sort();
  
  countries.forEach(country => {
    const label = document.createElement("label");
    label.className = "flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "mr-2";
    checkbox.value = country;
    checkbox.id = `locationCountry_${country.replace(/[^a-zA-Z0-9]/g, "_")}`;
    checkbox.checked = selectedCountries.has(country);
    checkbox.onchange = () => toggleCountryOption(country);
    label.appendChild(checkbox);
    
    const textNode = document.createTextNode(country);
    label.appendChild(textNode);
    
    countryOptions.appendChild(label);
  });
  
  updateSelectedLocationsTags();
}

// Update state options based on selected country
function updateLocationStates() {
  const stateContainer = $("locationLevel2");
  const stateOptions = $("locationStateOptions");
  
  if (!lastClickedCountry || !selectedCountries.has(lastClickedCountry)) {
    stateContainer.classList.add("hidden");
    return;
  }
  
  stateContainer.classList.remove("hidden");
  
  const states = Object.keys(locationHierarchy[lastClickedCountry] || {}).filter(s => s !== '_no_state').sort();
  
  if (states.length === 0) {
    stateContainer.classList.add("hidden");
    return;
  }
  
  stateOptions.innerHTML = "";
  
  states.forEach(state => {
    const label = document.createElement("label");
    label.className = "flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "mr-2";
    checkbox.value = state;
    checkbox.id = `locationState_${state.replace(/[^a-zA-Z0-9]/g, "_")}`;
    checkbox.checked = selectedStates.get(lastClickedCountry)?.has(state) || false;
    checkbox.onchange = () => toggleStateOption(state);
    label.appendChild(checkbox);
    
    const textNode = document.createTextNode(state);
    label.appendChild(textNode);
    
    stateOptions.appendChild(label);
  });
  
  // Also add option for locations with no state
  if (locationHierarchy[lastClickedCountry]['_no_state']) {
    const label = document.createElement("label");
    label.className = "flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "mr-2";
    checkbox.value = '_no_state';
    checkbox.id = `locationState_no_state`;
    checkbox.checked = selectedStates.get(lastClickedCountry)?.has('_no_state') || false;
    checkbox.onchange = () => toggleStateOption('_no_state');
    label.appendChild(checkbox);
    
    const textNode = document.createTextNode("(No state/region)");
    label.appendChild(textNode);
    
    stateOptions.appendChild(label);
  }
}

// Toggle country option
function toggleCountryOption(country) {
  const checkboxId = `locationCountry_${country.replace(/[^a-zA-Z0-9]/g, "_")}`;
  const checkbox = document.getElementById(checkboxId);
  if (checkbox) {
    if (checkbox.checked) {
      selectedCountries.add(country);
      lastClickedCountry = country;
      // Initialize state set for this country if needed
      if (!selectedStates.has(country)) {
        selectedStates.set(country, new Set());
      }
      // Hide state menu when a new country is clicked
      $("locationLevel2").classList.add("hidden");
    } else {
      selectedCountries.delete(country);
      // Remove states for this country
      selectedStates.delete(country);
      // If this was the last clicked, clear it
      if (lastClickedCountry === country) {
        lastClickedCountry = null;
        // Find the most recently selected country if any
        const countriesArray = Array.from(selectedCountries);
        lastClickedCountry = countriesArray.length > 0 ? countriesArray[countriesArray.length - 1] : null;
      }
    }
  }
  updateSelectedLocationsTags();
  updateLocationStates();
}

// Toggle state option
function toggleStateOption(state) {
  if (!lastClickedCountry) return;
  
  const checkboxId = `locationState_${state.replace(/[^a-zA-Z0-9]/g, "_")}`;
  const checkbox = document.getElementById(checkboxId);
  if (checkbox) {
    if (!selectedStates.has(lastClickedCountry)) {
      selectedStates.set(lastClickedCountry, new Set());
    }
    
    if (checkbox.checked) {
      selectedStates.get(lastClickedCountry).add(state);
    } else {
      selectedStates.get(lastClickedCountry).delete(state);
    }
  }
  updateSelectedLocationsTags();
}

// Populate selectedLocations from current country/state selections
function populateSelectedLocations() {
  selectedLocations.clear();
  
  selectedCountries.forEach(country => {
    const states = selectedStates.get(country) || new Set();
    
    if (states.size === 0) {
      // Country selected but no states - add all locations for this country
      const countryData = locationHierarchy[country] || {};
      Object.values(countryData).forEach(locationSet => {
        locationSet.forEach(loc => selectedLocations.add(loc));
      });
    } else {
      // States selected - add locations for those states
      states.forEach(state => {
        const locationSet = locationHierarchy[country]?.[state];
        if (locationSet) {
          locationSet.forEach(loc => selectedLocations.add(loc));
        }
      });
    }
  });
}

// Update selected locations tags display
function updateSelectedLocationsTags() {
  const tagsContainer = $("selectedLocationsTags");
  if (!tagsContainer) return;
  
  tagsContainer.innerHTML = "";
  
  // Populate selectedLocations from current selections
  populateSelectedLocations();
  
  // Display tags for selected countries and states
  selectedCountries.forEach(country => {
    const states = selectedStates.get(country) || new Set();
    
    if (states.size === 0) {
      // Show country tag
      const tag = document.createElement("span");
      tag.className = "inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800";
      tag.textContent = country;
      
      const removeBtn = document.createElement("button");
      removeBtn.className = "ml-1 text-blue-600 hover:text-blue-800";
      removeBtn.innerHTML = "×";
      removeBtn.onclick = () => {
        selectedCountries.delete(country);
        selectedStates.delete(country);
        if (lastClickedCountry === country) {
          lastClickedCountry = null;
          const countriesArray = Array.from(selectedCountries);
          lastClickedCountry = countriesArray.length > 0 ? countriesArray[countriesArray.length - 1] : null;
        }
        populateLocationCountries();
        updateLocationStates();
        updateSelectedLocationsTags();
      };
      tag.appendChild(removeBtn);
      tagsContainer.appendChild(tag);
    } else {
      // Show state tags
      states.forEach(state => {
        const tag = document.createElement("span");
        tag.className = "inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800";
        const stateLabel = state === '_no_state' ? '(No state/region)' : state;
        tag.textContent = `${country} > ${stateLabel}`;
        
        const removeBtn = document.createElement("button");
        removeBtn.className = "ml-1 text-blue-600 hover:text-blue-800";
        removeBtn.innerHTML = "×";
        removeBtn.onclick = () => {
          selectedStates.get(country)?.delete(state);
          if (selectedStates.get(country)?.size === 0) {
            selectedStates.delete(country);
          }
          updateLocationStates();
          updateSelectedLocationsTags();
        };
        tag.appendChild(removeBtn);
        tagsContainer.appendChild(tag);
      });
    }
  });
}

function populateSearchTreeLevel1() {
  const allowedTopLevels = ["AI", "Fintech", "Healthcare", "Commerce", "Other"];
  const topLevelOptions = $("searchTopLevelOptions");
  if (!topLevelOptions) return;

  topLevelOptions.innerHTML = "";
  const validKeys = Object.keys(treeHierarchy)
    .filter(k => allowedTopLevels.includes(k));

  validKeys.sort().forEach(k => {
    const label = document.createElement("label");
    label.className = "flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "mr-2";
    checkbox.value = k;
    checkbox.id = `searchTopLevel_${k.replace(/[^a-zA-Z0-9]/g, "_")}`;
    checkbox.onchange = () => toggleTopLevelOption(k);
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(k));
    topLevelOptions.appendChild(label);
  });
}



function buildTreeHierarchy(treePaths) {
  treeHierarchy = {};
  for (const path of treePaths) {
    const parts = path.split(" > ");
    parts.reduce((acc, part) => acc[part] ||= {}, treeHierarchy);
  }
}

function populateTreeLevel1() {
  const allowedTopLevels = ["AI", "Fintech", "Healthcare", "Commerce", "Other"];
  const l1Sel = $("treeLevel1");
  l1Sel.innerHTML = "<option value=''>All Top Categories</option>";

  const validKeys = Object.keys(treeHierarchy)
    .filter(k => allowedTopLevels.includes(k));

  for (const k of validKeys.sort()) {
    const opt = document.createElement("option");
    opt.value = k;
    opt.textContent = k;
    l1Sel.appendChild(opt);
  }

  $("treeLevel2").disabled = true;
  $("treeLevel3").disabled = true;
}


function updateTreeLevel2() {
  const l1 = $("treeLevel1").value;
  const l2Sel = $("treeLevel2");
  const l3Sel = $("treeLevel3");
  const l2Container = $("treeLevel2Container");
  const l3Container = $("treeLevel3Container");

  // reset
  l2Sel.innerHTML = "<option value=''>All Subcategories</option>";
  l3Sel.innerHTML = "<option value=''>All Sub-Subcategories</option>";
  l3Sel.disabled = true;
  l3Container.classList.add("hidden");

  if (!l1) {
    l2Sel.disabled = true;
    l2Container.classList.add("hidden");
    return;
  }

  const subs = Object.keys(treeHierarchy[l1] || {});
  l2Sel.disabled = !subs.length;
  l2Container.classList.toggle("hidden", !subs.length);

  for (const s of subs.sort()) {
    const opt = document.createElement("option");
    opt.value = s;
    opt.textContent = s;
    l2Sel.appendChild(opt);
  }
}

function updateTreeLevel3() {
  const l1 = $("treeLevel1").value;
  const l2 = $("treeLevel2").value;
  const l3Sel = $("treeLevel3");
  const l3Container = $("treeLevel3Container");

  l3Sel.innerHTML = "<option value=''>All Sub-Subcategories</option>";

  if (!l2) {
    l3Sel.disabled = true;
    l3Container.classList.add("hidden");
    return;
  }

  const subs = Object.keys(treeHierarchy[l1]?.[l2] || {});
  l3Sel.disabled = !subs.length;
  l3Container.classList.toggle("hidden", !subs.length);

  for (const s of subs.sort()) {
    const opt = document.createElement("option");
    opt.value = s;
    opt.textContent = s;
    l3Sel.appendChild(opt);
  }
}

function updateSearchTreeLevel2() {
  const l2Container = $("categoryLevel2");
  const l3Container = $("categoryLevel3");
  const subcategoryOptions = $("searchSubcategoryOptions");
  const subSubcategoryOptions = $("searchSubSubcategoryOptions");

  // Clear sub-subcategory display
  subSubcategoryOptions.innerHTML = "";
  l3Container.classList.add("hidden");

  // Only show subcategories for the last clicked top-level category
  if (!lastClickedTopLevel || !selectedTopLevels.has(lastClickedTopLevel)) {
    l2Container.classList.add("hidden");
    return;
  }

  l2Container.classList.remove("hidden");

  // Get subcategories only for the last clicked top-level category
  const subs = Object.keys(treeHierarchy[lastClickedTopLevel] || {});

  if (subs.length === 0) {
    l2Container.classList.add("hidden");
    return;
  }

  // Populate subcategory checkboxes
  subcategoryOptions.innerHTML = "";
  subs.sort().forEach(sub => {
    const label = document.createElement("label");
    label.className = "flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "mr-2";
    checkbox.value = sub;
    checkbox.id = `searchSubcategory_${sub.replace(/[^a-zA-Z0-9]/g, "_")}`;
    
    // Check if this subcategory is selected for this top level
    const isChecked = selectedSubcategories.get(lastClickedTopLevel)?.has(sub) || false;
    checkbox.checked = isChecked;
    
    checkbox.onchange = () => toggleSubcategoryOption(sub);
    label.appendChild(checkbox);
    
    const textNode = document.createTextNode(sub);
    label.appendChild(textNode);
    
    subcategoryOptions.appendChild(label);
  });

  updateSearchTreeLevel3();
}

function updateSearchTreeLevel3() {
  const l3Container = $("categoryLevel3");
  const subSubcategoryOptions = $("searchSubSubcategoryOptions");

  // Only show sub-subcategories for the last clicked top-level category
  if (!lastClickedTopLevel) {
    l3Container.classList.add("hidden");
    return;
  }

  // Get selected subcategories for the last clicked top-level category
  const subs = selectedSubcategories.get(lastClickedTopLevel) || new Set();
  
  if (subs.size === 0) {
    l3Container.classList.add("hidden");
    return;
  }

  l3Container.classList.remove("hidden");

  // Collect all sub-subcategories from selected subcategories of the last clicked top level
  const allSubSubs = new Set();
  subs.forEach(sub => {
    const subSubs = Object.keys(treeHierarchy[lastClickedTopLevel]?.[sub] || {});
    subSubs.forEach(subSub => allSubSubs.add(subSub));
  });

  if (allSubSubs.size === 0) {
    l3Container.classList.add("hidden");
    return;
  }

  // Populate sub-subcategory checkboxes
  subSubcategoryOptions.innerHTML = "";
  Array.from(allSubSubs).sort().forEach(subSub => {
    const label = document.createElement("label");
    label.className = "flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "mr-2";
    checkbox.value = subSub;
    checkbox.id = `searchSubSubcategory_${subSub.replace(/[^a-zA-Z0-9]/g, "_")}`;
    
    // Check if this sub-subcategory is selected for any selected subcategory of the last clicked top level
    let isChecked = false;
    subs.forEach(sub => {
      if (selectedSubSubcategories.get(lastClickedTopLevel)?.get(sub)?.has(subSub)) {
        isChecked = true;
      }
    });
    checkbox.checked = isChecked;
    
    checkbox.onchange = () => toggleSubSubcategoryOption(subSub);
    label.appendChild(checkbox);
    
    const textNode = document.createTextNode(subSub);
    label.appendChild(textNode);
    
    subSubcategoryOptions.appendChild(label);
  });

}

function getSearchSelectedTreePath() {
  // Legacy function for backward compatibility - returns first path or empty
  const paths = getSearchSelectedTreePaths();
  return paths.length > 0 ? paths[0] : "";
}

function getSearchSelectedTreePaths() {
  const paths = [];
  
  selectedTopLevels.forEach(topLevel => {
    const subs = selectedSubcategories.get(topLevel) || new Set();
    const subSubs = selectedSubSubcategories.get(topLevel) || new Map();
    
    if (subs.size === 0) {
      // Just top level selected - send as prefix (will match all children)
      paths.push(topLevel);
    } else {
      subs.forEach(sub => {
        const subSubSet = subSubs.get(sub) || new Set();
        if (subSubSet.size === 0) {
          // Top level + subcategory selected - send as prefix (will match all sub-subcategories)
          paths.push(`${topLevel} > ${sub}`);
        } else {
          // Top level + subcategory + sub-subcategory selected
          // Send the most specific path - API should do prefix matching
          subSubSet.forEach(subSub => {
            paths.push(`${topLevel} > ${sub} > ${subSub}`);
          });
        }
      });
    }
  });
  
  return paths;
}


function getSelectedTreePath() {
  const parts = [
    $("treeLevel1").value,
    $("treeLevel2").value,
    $("treeLevel3").value
  ].filter(Boolean);
  return parts.join(" > ");
}

// Helper function to create founder card HTML
function createFounderCardHTML(row, contactStatusMap = {}) {
  const company = row.company_name || "Unknown";
  const founder = row.name || "";
  const treePath = row.tree_path || "—";
  const location = row.location || "";
  const funding = row.funding || "";
  const businessStage = row.business_stage || "";
  const repeatFounder = row.repeat_founder === true || row.repeat_founder === "true" || String(row.repeat_founder).toLowerCase() === "true";
  const technical = row.technical === true || row.technical === "true" || String(row.technical).toLowerCase() === "true";
  const rawEntryId = resolveEntryId(row);
  const entryId = normalizeEntryId(rawEntryId);
  const status = entryId ? (contactStatusMap[entryId] || contactStatusCache.get(entryId)) : undefined;
  
  const isContacted = status ? Boolean(status.contacted) : false;
  const isInPipeline = status ? Boolean(status.in_pipeline) : false;
  const encodedEntryId = entryId ? encodeURIComponent(entryId) : "";
  const contactedMeta = status?.contacted ? formatContactedTimestamp(status.contacted_at) : "";
  const pipelineMeta = status?.in_pipeline ? formatContactedTimestamp(status.in_pipeline_at) : "";
  
  const tags = (row.company_tags || "")
    .split(",")
    .map(t => t.trim())
    .filter(t => t && t.toLowerCase() !== "none");
  
  const verticals = (row.verticals || "")
    .split(",")
    .map(v => v.trim())
    .filter(v => v && v.toLowerCase() !== "none")
    .map(v => v.replace(/\s*\([^)]*\)\s*/g, '').trim())
    .filter(v => v);

  const history = (row.history || "").trim();
  const historyDisplay = history ? `<span class="text-xs bg-gray-100 text-gray-700 px-2 py-0.5 rounded-full font-medium">${history}</span>` : "";

  return `
    <div class="space-y-3">
      <div class="flex items-start justify-between gap-3">
        <div>
        <div class="flex items-center gap-2 flex-wrap">
          <h3 class="font-semibold text-brand text-lg">${company}</h3>
          ${historyDisplay}
        </div>
        ${founder ? `<p class="text-xs text-gray-600 mt-0.5">${founder}</p>` : ""}
        <p class="text-xs text-gray-500 mt-1">${treePath}</p>
        </div>
        ${entryId ? `
          <div class="status-controls flex flex-col items-end gap-1 text-[10px] leading-snug text-gray-600 min-w-[120px]">
            <div class="status-group flex flex-col items-end gap-0.5 w-full">
              <label class="status-toggle grid grid-cols-[auto_minmax(12px,16px)] items-center gap-x-1 gap-y-0.5 w-full">
                <span class="text-right">Reached out</span>
                <input type="checkbox"
                       class="founder-status-toggle accent-blue-600 h-3 w-3 justify-self-end"
                       data-entry-id="${encodedEntryId}"
                       data-status-type="contacted"
                       ${isContacted ? "checked" : ""} />
              </label>
              <span class="status-meta text-[9px] text-gray-500 uppercase tracking-wide ${contactedMeta ? "" : "hidden"}"
                    data-status-type="contacted">
                ${contactedMeta ? `Updated ${contactedMeta}` : ""}
              </span>
            </div>
            <div class="status-group flex flex-col items-end gap-0.5 w-full">
              <label class="status-toggle grid grid-cols-[auto_minmax(12px,16px)] items-center gap-x-1 gap-y-0.5 w-full">
                <span class="text-right">In pipeline</span>
                <input type="checkbox"
                       class="founder-status-toggle accent-blue-600 h-3 w-3 justify-self-end"
                       data-entry-id="${encodedEntryId}"
                       data-status-type="in_pipeline"
                       ${isInPipeline ? "checked" : ""} />
              </label>
              <span class="status-meta text-[9px] text-gray-500 uppercase tracking-wide ${pipelineMeta ? "" : "hidden"}"
                    data-status-type="in_pipeline">
                ${pipelineMeta ? `Updated ${pipelineMeta}` : ""}
              </span>
            </div>
          </div>
        ` : ""}
      </div>
      
      ${location || funding || businessStage ? `
        <div class="flex flex-wrap gap-x-4 gap-y-1 text-xs text-gray-600">
          ${location ? `<span>📍 ${location}</span>` : ""}
          ${businessStage ? `<span>🏢 ${businessStage}</span>` : ""}
          ${funding ? `<span>💰 ${funding}</span>` : ""}
        </div>
      ` : ""}
      
      ${repeatFounder || technical ? `
        <div class="flex flex-wrap gap-1">
          ${repeatFounder ? `<span class="text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded-full">Repeat Founder</span>` : ""}
          ${technical ? `<span class="text-xs bg-purple-100 text-purple-700 px-2 py-0.5 rounded-full">Technical</span>` : ""}
        </div>
      ` : ""}
      
      ${verticals.length > 0 ? `
        <div class="flex flex-wrap gap-1">
          ${verticals.slice(0, 2).map(v => `<span class="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded-full">${v}</span>`).join("")}
          ${verticals.length > 2 ? `<span class="text-xs text-gray-500">+${verticals.length - 2} more</span>` : ""}
        </div>
      ` : ""}
      
      ${tags.length > 0 ? `
        <div class="flex flex-wrap gap-1">
          ${tags.slice(0, 2).map(t => `<span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full">${t}</span>`).join("")}
          ${tags.length > 2 ? `<span class="text-xs text-gray-500">+${tags.length - 2} more</span>` : ""}
        </div>
      ` : ""}
    </div>
  `;
}

async function loadRecommendedFiltered() {
  const treePath = getSelectedTreePath();

  $("foundersLoading").classList.remove("hidden");
  $("recommendedResults").classList.add("hidden");
  $("recommendedScroll").innerHTML = "";

  try {
    const query = treePath ? `?tree_path_prefix=${encodeURIComponent(treePath)}` : "";
    const res = await fetch(`${FOUNDERS_API}/recommended-founders${query}`, {
      headers: { "x-api-key": API_KEY }
    });
    const json = await res.json();
    const data = sortFoundersByAccessDateDesc(json.data || []);

    $("foundersLoading").classList.add("hidden");

    if (!data.length) {
      $("recommendedResults").classList.remove("hidden");
      $("recommendedScroll").innerHTML = `<p class="text-gray-500 px-4">No results found.</p>`;
      return;
    }

    // Show results immediately, lazy load contact status for visible cards
    const scroll = $("recommendedScroll");
    for (const row of data.slice(0, 50)) {
      const card = document.createElement("div");
      card.className = "bg-gray-50 border border-gray-200 rounded-lg p-4 hover:shadow-md cursor-pointer transition-shadow";
      const entryId = normalizeEntryId(resolveEntryId(row));
      
      // Show without contact status first (will load lazily when visible)
      card.innerHTML = createFounderCardHTML(row, {});
      attachContactStatusHandlers(card, row);
      card.addEventListener("click", () => openFounderModal(row));
      scroll.appendChild(card);
      
      // Register for lazy loading
      if (contactStatusLazyLoader.observer) {
        contactStatusLazyLoader.observeCard(card, entryId, row);
      }
    }

    $("recommendedResults").classList.remove("hidden");
  } catch (err) {
    console.error(err);
    $("foundersLoading").classList.add("hidden");
    $("recommendedScroll").innerHTML = `<p class="text-red-500 px-4">Error loading data.</p>`;
  }
}

// Load dashboard recommendations (top 5)
async function loadDashboardRecommendations() {
  const loadingEl = $("dashboardFoundersLoading");
  const listEl = $("dashboardFoundersList");
  
  if (!loadingEl || !listEl) return; // Dashboard not visible
  
  loadingEl.classList.remove("hidden");
  listEl.innerHTML = "";

  try {
    const res = await fetch(`${FOUNDERS_API}/recommended-founders`, {
      headers: { "x-api-key": API_KEY }
    });
    const json = await res.json();
    const sortedData = sortFoundersByAccessDateDesc(json.data || []);
    const data = dedupeFoundersByCompany(sortedData);

    loadingEl.classList.add("hidden");

    if (!data.length) {
      listEl.innerHTML = `<p class="text-gray-500 text-sm text-center py-4">No recommendations available.</p>`;
      return;
    }

    // Show only top 5
    const top5 = data.slice(0, 5);

    // For dashboard (only 5 items), use lazy loading but check cache first
    top5.forEach((row) => {
      const card = document.createElement("div");
      card.className = "bg-gray-50 border border-gray-200 rounded-lg p-4 hover:shadow-md cursor-pointer transition-shadow";
      const entryId = normalizeEntryId(resolveEntryId(row));
      
      // Use cached status if available, otherwise will load lazily
      const contactStatusMap = contactStatusCache.has(entryId) 
        ? { [entryId]: contactStatusCache.get(entryId) } 
        : {};
      
      card.innerHTML = createFounderCardHTML(row, contactStatusMap);
      attachContactStatusHandlers(card, row);
      card.addEventListener("click", () => {
        showModule('foundersModule');
        // Small delay to ensure module is visible before opening modal
        setTimeout(() => openFounderModal(row), 100);
      });
      listEl.appendChild(card);
      
      // Mark as dashboard card and register for lazy loading if not cached
      card.setAttribute('data-dashboard-card', 'true');
      if (!contactStatusCache.has(entryId) && contactStatusLazyLoader.observer) {
        contactStatusLazyLoader.observeCard(card, entryId, row);
      }
    });

  } catch (err) {
    console.error("Failed to load dashboard recommendations", err);
    loadingEl.classList.add("hidden");
    listEl.innerHTML = `<p class="text-red-500 text-sm text-center py-4">Error loading recommendations.</p>`;
  }
}

// Load dashboard pre-seed deals (top 5)
async function loadDashboardDeals() {
  const loadingEl = $("dashboardDealsLoading");
  const listEl = $("dashboardDealsList");
  
  if (!loadingEl || !listEl) return; // Dashboard not visible
  
  loadingEl.classList.remove("hidden");
  listEl.innerHTML = "";

  try {
    const res = await fetch(`${API_URL}/api/deals`);
    const json = await res.json();
    
    if (!json.success) {
      throw new Error(json.error || "Failed to load deals");
    }
    
    const allDeals = json.data || [];
    
    // Deduplicate deals by company name first
    const uniqueDeals = deduplicateDealsByCompany(allDeals);
    
    // Filter for pre-seed deals (case-insensitive)
    const preSeedDeals = uniqueDeals.filter(deal => {
      const fundingRound = (deal.funding_round || deal["funding_round"] || "").toLowerCase();
      return fundingRound.includes("pre-seed") || fundingRound.includes("pre seed");
    });
    
    loadingEl.classList.add("hidden");

    if (!preSeedDeals.length) {
      listEl.innerHTML = `<p class="text-gray-500 text-sm text-center py-4">No pre-seed deals available.</p>`;
      return;
    }

    // Show only top 5 most recent
    const top5 = preSeedDeals.slice(0, 5);
    
    top5.forEach((deal) => {
      const card = document.createElement("div");
      card.className = "bg-gray-50 border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow";
      card.innerHTML = createDashboardDealCardHTML(deal);
      listEl.appendChild(card);
    });

  } catch (err) {
    console.error("Failed to load dashboard deals", err);
    loadingEl.classList.add("hidden");
    listEl.innerHTML = `<p class="text-red-500 text-sm text-center py-4">Error loading deals.</p>`;
  }
}

// Helper function to create compact deal card HTML for dashboard
function createDashboardDealCardHTML(deal) {
  const company = deal.company || "Unknown";
  const amount = deal.amount || "";
  const investors = formatInvestors(deal.investors);
  const date = deal.date || "";
  const category = deal.category || "";

  return `
    <div class="space-y-2">
      <div>
        <h3 class="font-semibold text-brand text-base">${company}</h3>
        ${date ? `<p class="text-xs text-gray-500 mt-0.5">${date}</p>` : ""}
      </div>
      
      ${amount ? `
        <div class="text-xs text-gray-600">
          <span class="font-semibold text-green-600">💰 ${amount}</span>
        </div>
      ` : ""}
      
      ${investors ? `
        <div class="text-xs text-gray-600">
          <span class="font-medium">Investors:</span> ${investors}
        </div>
      ` : ""}
      
      ${category ? `
        <div class="flex flex-wrap gap-1">
          <span class="text-xs bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded-full">${category}</span>
        </div>
      ` : ""}
    </div>
  `;
}

function showTab(tab) {
  const recommendedBtn = $("recommendedTab");
  const searchBtn = $("searchTab");

  // Reset all tab styles
  [recommendedBtn, searchBtn].forEach(btn => {
    btn.classList.remove("active");
    btn.classList.remove("border-blue-700", "text-blue-700");
    btn.classList.add("border-transparent", "text-gray-600");
  });

  // Set active tab
  const activeBtn = tab === "recommended" ? recommendedBtn : searchBtn;
  activeBtn.classList.add("active", "border-blue-700", "text-blue-700");
  activeBtn.classList.remove("border-transparent", "text-gray-600");

  // Show correct panels
  $("treePathFilters").classList.add("hidden");
  $("searchPanel")?.classList.add("hidden");
  $("recommendedResults").classList.add("hidden");
  $("searchResults").classList.add("hidden");

  if (tab === "recommended") {
    $("treePathFilters").classList.remove("hidden");
    $("recommendedResults").classList.remove("hidden");
    if ($("recommendedScroll").children.length === 0) loadRecommendedFiltered();
  } else {
    $("searchPanel")?.classList.remove("hidden");
    // Always hide recommended results when on search tab
    $("recommendedResults").classList.add("hidden");
    const hasResults = $("searchScroll").children.length > 0;
    $("searchResults").classList.toggle("hidden", !hasResults);
  }
}

// Multi-select state
let selectedCategories = new Set();
let selectedFundingRounds = new Set();

// Search multi-select state
let selectedTopLevels = new Set();
let selectedSubcategories = new Map(); // Map of topLevel -> Set of subcategories
let selectedSubSubcategories = new Map(); // Map of topLevel -> Map of subcategory -> Set of subSubcategories
let selectedLocations = new Set();
let lastClickedTopLevel = null; // Track the most recently clicked top-level category

// Location hierarchy state
let locationHierarchy = {}; // Map of country -> Map of state -> Set of location strings
let selectedCountries = new Set();
let selectedStates = new Map(); // Map of country -> Set of states
let lastClickedCountry = null; // Track the most recently clicked country

// Toggle multi-select dropdown
function toggleMultiSelect(type) {
  const dropdown = $(type + "Dropdown");
  if (dropdown) {
    dropdown.classList.toggle("hidden");
    // Close other dropdowns
    if (type === "dealCategory") {
      $("dealFundingRoundDropdown")?.classList.add("hidden");
    } else {
      $("dealCategoryDropdown")?.classList.add("hidden");
    }
  }
}

// Close dropdowns when clicking outside
document.addEventListener("click", (e) => {
  const categoryDropdown = $("dealCategoryDropdown");
  const fundingDropdown = $("dealFundingRoundDropdown");
  const subcategoryDropdown = $("searchSubcategoryDropdown");
  const subSubcategoryDropdown = $("searchSubSubcategoryDropdown");
  const locationDropdown = $("searchLocationDropdown");
  
  // Check if click is outside category dropdown and its button
  if (categoryDropdown && !categoryDropdown.contains(e.target) && 
      !e.target.closest("button[onclick*='dealCategory']")) {
    categoryDropdown.classList.add("hidden");
  }
  
  // Check if click is outside funding round dropdown and its button
  if (fundingDropdown && !fundingDropdown.contains(e.target) && 
      !e.target.closest("button[onclick*='dealFundingRound']")) {
    fundingDropdown.classList.add("hidden");
  }
  
  const topLevelDropdown = $("searchTopLevelDropdown");
  
  // Check if click is outside search top level dropdown and its button
  if (topLevelDropdown && !topLevelDropdown.contains(e.target) && 
      !e.target.closest("button[onclick*='searchTopLevel']")) {
    topLevelDropdown.classList.add("hidden");
  }
  
  // Check if click is outside search subcategory dropdown and its button
  if (subcategoryDropdown && !subcategoryDropdown.contains(e.target) && 
      !e.target.closest("button[onclick*='searchSubcategory']")) {
    subcategoryDropdown.classList.add("hidden");
  }
  
  // Check if click is outside search sub-subcategory dropdown and its button
  if (subSubcategoryDropdown && !subSubcategoryDropdown.contains(e.target) && 
      !e.target.closest("button[onclick*='searchSubSubcategory']")) {
    subSubcategoryDropdown.classList.add("hidden");
  }
  
  // Check if click is outside search location dropdown and its button
  if (locationDropdown && !locationDropdown.contains(e.target) && 
      !e.target.closest("button[onclick*='searchLocation']")) {
    locationDropdown.classList.add("hidden");
  }
  
  // Check if click is outside category cascade menu and its button
  const categoryCascadeMenu = $("categoryCascadeMenu");
  if (categoryCascadeMenu && !categoryCascadeMenu.contains(e.target) && 
      !e.target.closest("button[onclick*='toggleCategoryMenu']")) {
    categoryCascadeMenu.classList.add("hidden");
  }
  
  // Check if click is outside location cascade menu and its button
  const locationCascadeMenu = $("locationCascadeMenu");
  if (locationCascadeMenu && !locationCascadeMenu.contains(e.target) && 
      !e.target.closest("button[onclick*='toggleLocationMenu']")) {
    locationCascadeMenu.classList.add("hidden");
  }
});

// Toggle category option
function toggleCategoryOption(value) {
  if (value === "all") {
    const allChecked = $("dealCategoryAll").checked;
    selectedCategories.clear();
    if (allChecked) {
      // Select all categories
      document.querySelectorAll("#dealCategoryOptions input[type='checkbox']").forEach(cb => {
        if (cb.id !== "dealCategoryAll") {
          cb.checked = true;
          selectedCategories.add(cb.value);
        }
      });
    } else {
      // Unselect all
      document.querySelectorAll("#dealCategoryOptions input[type='checkbox']").forEach(cb => {
        cb.checked = false;
      });
    }
  } else {
    const checkboxId = `dealCategory_${value.replace(/[^a-zA-Z0-9]/g, "_")}`;
    const checkbox = document.getElementById(checkboxId);
    if (checkbox) {
      if (checkbox.checked) {
        selectedCategories.add(value);
        // Uncheck "All" if a specific option is selected
        $("dealCategoryAll").checked = false;
      } else {
        selectedCategories.delete(value);
      }
    }
  }
  updateCategoryDisplay();
  loadDeals();
}

// Toggle funding round option
function toggleFundingRoundOption(value) {
  if (value === "all") {
    const allChecked = $("dealFundingRoundAll").checked;
    selectedFundingRounds.clear();
    if (allChecked) {
      // Select all funding rounds
      document.querySelectorAll("#dealFundingRoundOptions input[type='checkbox']").forEach(cb => {
        if (cb.id !== "dealFundingRoundAll") {
          cb.checked = true;
          selectedFundingRounds.add(cb.value);
        }
      });
    } else {
      // Unselect all
      document.querySelectorAll("#dealFundingRoundOptions input[type='checkbox']").forEach(cb => {
        cb.checked = false;
      });
    }
  } else {
    const checkboxId = `dealFundingRound_${value.replace(/[^a-zA-Z0-9]/g, "_")}`;
    const checkbox = document.getElementById(checkboxId);
    if (checkbox) {
      if (checkbox.checked) {
        selectedFundingRounds.add(value);
        // Uncheck "All" if a specific option is selected
        $("dealFundingRoundAll").checked = false;
      } else {
        selectedFundingRounds.delete(value);
      }
    }
  }
  updateFundingRoundDisplay();
  loadDeals();
}

// Update category display text
function updateCategoryDisplay() {
  const display = $("dealCategoryDisplay");
  if (selectedCategories.size === 0) {
    display.textContent = "All Categories";
  } else if (selectedCategories.size === 1) {
    display.textContent = Array.from(selectedCategories)[0];
  } else {
    display.textContent = `${selectedCategories.size} selected`;
  }
}

// Update funding round display text
function updateFundingRoundDisplay() {
  const display = $("dealFundingRoundDisplay");
  if (selectedFundingRounds.size === 0) {
    display.textContent = "All Funding Rounds";
  } else if (selectedFundingRounds.size === 1) {
    display.textContent = Array.from(selectedFundingRounds)[0];
  } else {
    display.textContent = `${selectedFundingRounds.size} selected`;
  }
}

// Toggle search multi-select dropdown (for location)
function toggleSearchMultiSelect(type) {
  const dropdown = $(type + "Dropdown");
  if (dropdown) {
    dropdown.classList.toggle("hidden");
    // Close other search dropdowns
    const allSearchDropdowns = ["searchLocationDropdown"];
    allSearchDropdowns.forEach(dd => {
      if (dd !== type + "Dropdown") {
        $(dd)?.classList.add("hidden");
      }
    });
  }
}

// Toggle top-level category option
function toggleTopLevelOption(value) {
  if (value === "all") {
    const allChecked = $("searchTopLevelAll").checked;
    selectedTopLevels.clear();
    selectedSubcategories.clear();
    selectedSubSubcategories.clear();
    lastClickedTopLevel = null;
    if (allChecked) {
      // Select all top-level categories
      document.querySelectorAll("#searchTopLevelOptions input[type='checkbox']").forEach(cb => {
        if (cb.id !== "searchTopLevelAll") {
          cb.checked = true;
          selectedTopLevels.add(cb.value);
        }
      });
    } else {
      // Unselect all
      document.querySelectorAll("#searchTopLevelOptions input[type='checkbox']").forEach(cb => {
        cb.checked = false;
      });
    }
    // Hide level 2 and 3 when unselecting all
    $("categoryLevel2").classList.add("hidden");
    $("categoryLevel3").classList.add("hidden");
  } else {
    const checkboxId = `searchTopLevel_${value.replace(/[^a-zA-Z0-9]/g, "_")}`;
    const checkbox = document.getElementById(checkboxId);
    if (checkbox) {
      if (checkbox.checked) {
        selectedTopLevels.add(value);
        // Track this as the last clicked top-level category
        lastClickedTopLevel = value;
        // Initialize subcategory set for this top level if needed
        if (!selectedSubcategories.has(value)) {
          selectedSubcategories.set(value, new Set());
        }
        // Uncheck "All" if a specific option is selected
        $("searchTopLevelAll").checked = false;
        // Hide sub-subcategories when a new top-level is clicked
        $("categoryLevel3").classList.add("hidden");
      } else {
        selectedTopLevels.delete(value);
        // Remove subcategories for this top level
        selectedSubcategories.delete(value);
        selectedSubSubcategories.delete(value);
        // If this was the last clicked, clear it
        if (lastClickedTopLevel === value) {
          lastClickedTopLevel = null;
          // Find the most recently selected top-level if any
          const topLevelsArray = Array.from(selectedTopLevels);
          lastClickedTopLevel = topLevelsArray.length > 0 ? topLevelsArray[topLevelsArray.length - 1] : null;
        }
      }
    }
  }
  updateSelectedCategoriesTags();
  updateSearchTreeLevel2();
}


// Update selected categories tags display
function updateSelectedCategoriesTags() {
  const tagsContainer = $("selectedCategoriesTags");
  if (!tagsContainer) return;
  
  tagsContainer.innerHTML = "";
  
  // Build a flat list of all selected category paths
  const allPaths = [];
  
  selectedTopLevels.forEach(topLevel => {
    const subs = selectedSubcategories.get(topLevel) || new Set();
    const subSubs = selectedSubSubcategories.get(topLevel) || new Map();
    
    if (subs.size === 0) {
      // Just top level selected
      allPaths.push({ path: topLevel, fullPath: topLevel, level: 1 });
    } else {
      subs.forEach(sub => {
        const subSubSet = subSubs.get(sub) || new Set();
        if (subSubSet.size === 0) {
          // Top level + subcategory
          allPaths.push({ path: `${topLevel} > ${sub}`, fullPath: `${topLevel} > ${sub}`, level: 2, topLevel, sub });
        } else {
          // Top level + subcategory + sub-subcategory
          subSubSet.forEach(subSub => {
            allPaths.push({ path: `${topLevel} > ${sub} > ${subSub}`, fullPath: `${topLevel} > ${sub} > ${subSub}`, level: 3, topLevel, sub, subSub });
          });
        }
      });
    }
  });
  
  // Display tags
  allPaths.forEach(({ fullPath, level, topLevel, sub, subSub }) => {
    const tag = document.createElement("div");
    tag.className = "inline-flex items-center gap-1 bg-blue-100 text-blue-700 px-2 py-1 rounded-full text-sm";
    
    const span = document.createElement("span");
    span.textContent = fullPath;
    tag.appendChild(span);
    
    const button = document.createElement("button");
    button.type = "button";
    button.className = "ml-1 text-blue-700 hover:text-blue-900 font-bold";
    button.textContent = "×";
    button.onclick = () => removeCategoryTag(topLevel, sub || null, subSub || null);
    tag.appendChild(button);
    
    tagsContainer.appendChild(tag);
  });
}

// Remove a category tag
function removeCategoryTag(topLevel, sub, subSub) {
  if (subSub !== null && subSub !== undefined) {
    // Remove sub-subcategory
    const subSubMap = selectedSubSubcategories.get(topLevel);
    if (subSubMap) {
      const subSubSet = subSubMap.get(sub);
      if (subSubSet) {
        subSubSet.delete(subSub);
        if (subSubSet.size === 0) {
          subSubMap.delete(sub);
        }
        // Also uncheck the checkbox
        const checkboxId = `searchSubSubcategory_${subSub.replace(/[^a-zA-Z0-9]/g, "_")}`;
        const checkbox = document.getElementById(checkboxId);
        if (checkbox) {
          // Check if this sub-subcategory is still selected elsewhere
          let stillSelected = false;
          selectedTopLevels.forEach(tl => {
            const ssMap = selectedSubSubcategories.get(tl);
            if (ssMap) {
              ssMap.forEach((ssSet, s) => {
                if (ssSet.has(subSub)) stillSelected = true;
              });
            }
          });
          if (!stillSelected) checkbox.checked = false;
        }
      }
      if (subSubMap.size === 0) {
        selectedSubSubcategories.delete(topLevel);
      }
    }
  } else if (sub !== null && sub !== undefined) {
    // Remove subcategory (and all its sub-subcategories)
    selectedSubcategories.get(topLevel)?.delete(sub);
    selectedSubSubcategories.get(topLevel)?.delete(sub);
    // Uncheck the checkbox
    const checkboxId = `searchSubcategory_${sub.replace(/[^a-zA-Z0-9]/g, "_")}`;
    const checkbox = document.getElementById(checkboxId);
    if (checkbox) {
      // Check if this subcategory is still selected elsewhere
      let stillSelected = false;
      selectedTopLevels.forEach(tl => {
        if (selectedSubcategories.get(tl)?.has(sub)) stillSelected = true;
      });
      if (!stillSelected) checkbox.checked = false;
    }
  } else {
    // Remove top level (and all its subcategories)
    selectedTopLevels.delete(topLevel);
    selectedSubcategories.delete(topLevel);
    selectedSubSubcategories.delete(topLevel);
    // Uncheck the checkbox
    const checkboxId = `searchTopLevel_${topLevel.replace(/[^a-zA-Z0-9]/g, "_")}`;
    const checkbox = document.getElementById(checkboxId);
    if (checkbox) checkbox.checked = false;
  }
  
  updateSelectedCategoriesTags();
  updateSearchTreeLevel2();
  updateSearchTreeLevel3();
}

// Toggle subcategory option
function toggleSubcategoryOption(value) {
  const checkboxId = `searchSubcategory_${value.replace(/[^a-zA-Z0-9]/g, "_")}`;
  const checkbox = document.getElementById(checkboxId);
  if (checkbox && lastClickedTopLevel) {
    if (checkbox.checked) {
      // Add this subcategory to the last clicked top level
      if (!selectedSubcategories.has(lastClickedTopLevel)) {
        selectedSubcategories.set(lastClickedTopLevel, new Set());
      }
      selectedSubcategories.get(lastClickedTopLevel).add(value);
    } else {
      // Remove this subcategory from the last clicked top level
      selectedSubcategories.get(lastClickedTopLevel)?.delete(value);
      selectedSubSubcategories.get(lastClickedTopLevel)?.delete(value);
    }
  }
  updateSelectedCategoriesTags();
  // Update sub-subcategories when subcategory changes
  updateSearchTreeLevel3();
}

// Toggle sub-subcategory option
function toggleSubSubcategoryOption(value) {
  const checkboxId = `searchSubSubcategory_${value.replace(/[^a-zA-Z0-9]/g, "_")}`;
  const checkbox = document.getElementById(checkboxId);
  if (checkbox && lastClickedTopLevel) {
    const subs = selectedSubcategories.get(lastClickedTopLevel) || new Set();
    if (checkbox.checked) {
      // Add this sub-subcategory to all selected subcategories of the last clicked top level
      subs.forEach(sub => {
        if (treeHierarchy[lastClickedTopLevel]?.[sub]?.[value]) {
          if (!selectedSubSubcategories.has(lastClickedTopLevel)) {
            selectedSubSubcategories.set(lastClickedTopLevel, new Map());
          }
          const subSubMap = selectedSubSubcategories.get(lastClickedTopLevel);
          if (!subSubMap.has(sub)) {
            subSubMap.set(sub, new Set());
          }
          subSubMap.get(sub).add(value);
        }
      });
    } else {
      // Remove this sub-subcategory from all subcategories of the last clicked top level
      const subSubMap = selectedSubSubcategories.get(lastClickedTopLevel);
      if (subSubMap) {
        subSubMap.forEach((subSubSet, sub) => {
          subSubSet.delete(value);
          if (subSubSet.size === 0) {
            subSubMap.delete(sub);
          }
        });
        if (subSubMap.size === 0) {
          selectedSubSubcategories.delete(lastClickedTopLevel);
        }
      }
    }
  }
  updateSelectedCategoriesTags();
}

// Toggle location option
// Old toggleLocationOption and updateLocationDisplay functions removed - replaced with cascading menu

// Load deals filters (categories and funding rounds)
async function loadDealsFilters() {
  try {
    const res = await fetch(`${API_URL}/api/deals/filters`);
    const json = await res.json();
    if (!json.success) throw new Error("Failed to load filters");

    const categories = json.data.categories || [];
    const fundingRounds = json.data.funding_rounds || [];

    // Populate category checkboxes
    const categoryOptions = $("dealCategoryOptions");
    if (categoryOptions) {
      categoryOptions.innerHTML = "";
      categories.forEach(cat => {
        const label = document.createElement("label");
        label.className = "flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "mr-2";
        checkbox.value = cat;
        checkbox.id = `dealCategory_${cat.replace(/[^a-zA-Z0-9]/g, "_")}`;
        checkbox.onchange = () => toggleCategoryOption(cat);
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(cat));
        categoryOptions.appendChild(label);
      });
    }

    // Populate funding round checkboxes
    const fundingOptions = $("dealFundingRoundOptions");
    if (fundingOptions) {
      fundingOptions.innerHTML = "";
      fundingRounds.forEach(round => {
        const label = document.createElement("label");
        label.className = "flex items-center p-2 hover:bg-gray-50 cursor-pointer rounded";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "mr-2";
        checkbox.value = round;
        checkbox.id = `dealFundingRound_${round.replace(/[^a-zA-Z0-9]/g, "_")}`;
        checkbox.onchange = () => toggleFundingRoundOption(round);
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(round));
        fundingOptions.appendChild(label);
      });
    }
  } catch (e) {
    console.error("Failed to load deals filters", e);
  }
}

// Load and display deals
async function loadDeals() {
  const loadingEl = $("dealsLoading");
  const resultsEl = $("dealsResults");
  const scrollEl = $("dealsScroll");

  if (!loadingEl || !resultsEl || !scrollEl) return;

  loadingEl.classList.remove("hidden");
  resultsEl.classList.add("hidden");
  scrollEl.innerHTML = "";

  try {
    const query = new URLSearchParams();
    
    // Add categories if any are selected
    if (selectedCategories.size > 0) {
      Array.from(selectedCategories).forEach(cat => {
        query.append("category", cat);
      });
    }
    
    // Add funding rounds if any are selected
    if (selectedFundingRounds.size > 0) {
      Array.from(selectedFundingRounds).forEach(round => {
        query.append("funding_round", round);
      });
    }

    const res = await fetch(`${API_URL}/api/deals?${query.toString()}`);
    const json = await res.json();

    if (!json.success) {
      throw new Error(json.error || "Failed to load deals");
    }

    const allDeals = json.data || [];
    
    // Deduplicate deals by company name
    const deals = deduplicateDealsByCompany(allDeals);
    
    loadingEl.classList.add("hidden");

    if (!deals.length) {
      resultsEl.classList.remove("hidden");
      scrollEl.innerHTML = `<p class="text-gray-500 px-4">No deals found.</p>`;
      return;
    }

    // Display deals
    deals.forEach(deal => {
      const card = document.createElement("div");
      card.className = "bg-gray-50 border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow";
      card.innerHTML = createDealCardHTML(deal);
      scrollEl.appendChild(card);
    });

    resultsEl.classList.remove("hidden");
  } catch (err) {
    console.error("Failed to load deals", err);
    loadingEl.classList.add("hidden");
    resultsEl.classList.remove("hidden");
    scrollEl.innerHTML = `<p class="text-red-500 px-4">Error loading deals: ${err.message}</p>`;
  }
}

// Helper function to deduplicate deals by company name (case-insensitive)
// Keeps the first occurrence (most recent) for each company
function deduplicateDealsByCompany(deals) {
  if (!deals || !Array.isArray(deals)) return [];
  
  const seen = new Set();
  const deduplicated = [];
  
  for (const deal of deals) {
    const companyName = (deal.company || deal["company"] || "").trim();
    if (!companyName) {
      // Include deals without company names (they won't be duplicates)
      deduplicated.push(deal);
      continue;
    }
    
    // Case-insensitive comparison
    const companyKey = companyName.toLowerCase();
    
    if (!seen.has(companyKey)) {
      seen.add(companyKey);
      deduplicated.push(deal);
    }
  }
  
  return deduplicated;
}

// Helper function to format investors string
function formatInvestors(investors) {
  if (!investors) return "";
  
  // If it's already an array, use it directly
  if (Array.isArray(investors)) {
    return investors.filter(Boolean).join(", ");
  }
  
  // Convert to string
  const investorsStr = String(investors).trim();
  if (!investorsStr) return "";
  
  // Try to parse as JSON array first
  try {
    const parsed = JSON.parse(investorsStr);
    if (Array.isArray(parsed)) {
      return parsed.filter(Boolean).join(", ");
    }
  } catch (e) {
    // Not valid JSON, continue with other parsing
  }
  
  // Check if it looks like a Python list string representation (e.g., "['Name1', 'Name2']")
  const listMatch = investorsStr.match(/^\[(.*)\]$/);
  if (listMatch) {
    const content = listMatch[1];
    // Extract quoted strings
    const items = content.match(/'([^']+)'/g) || content.match(/"([^"]+)"/g);
    if (items) {
      return items.map(item => item.slice(1, -1)).filter(Boolean).join(", ");
    }
    // If no quotes, try splitting by comma
    return content.split(',').map(item => item.trim()).filter(Boolean).join(", ");
  }
  
  // If it's a comma-separated string, return it as is (already formatted)
  // But clean up any extra whitespace
  return investorsStr.split(',').map(item => item.trim()).filter(Boolean).join(", ");
}

// Helper function to create deal card HTML
function createDealCardHTML(deal) {
  const company = deal.company || "Unknown";
  const amount = deal.amount || "";
  const fundingRound = deal.funding_round || "";
  const vertical = deal.vertical || "";
  const link = deal.link || "";
  const investors = formatInvestors(deal.investors);
  const category = deal.category || "";
  const source = deal.source || "";
  const date = deal.date || "";

  return `
    <div class="space-y-2">
      <div>
        <h3 class="font-semibold text-brand text-lg">${company}</h3>
        ${date ? `<p class="text-xs text-gray-500 mt-1">${date}</p>` : ""}
      </div>
      
      ${amount || fundingRound ? `
        <div class="flex flex-wrap gap-x-4 gap-y-1 text-xs text-gray-600">
          ${amount ? `<span class="font-semibold text-green-600">💰 ${amount}</span>` : ""}
          ${fundingRound ? `<span>📊 ${fundingRound}</span>` : ""}
        </div>
      ` : ""}
      
      ${category || vertical ? `
        <div class="flex flex-wrap gap-1">
          ${category ? `<span class="text-xs bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded-full">${category}</span>` : ""}
          ${vertical ? `<span class="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded-full">${vertical}</span>` : ""}
        </div>
      ` : ""}
      
      ${investors ? `
        <div class="text-xs text-gray-600">
          <span class="font-medium">Investors:</span> ${investors}
        </div>
      ` : ""}
      
      ${source ? `
        <div class="text-xs text-gray-500">
          <span class="font-medium">Source:</span> ${source}
        </div>
      ` : ""}
      
      ${link ? `
        <div class="pt-2">
          <a href="${link}" target="_blank" class="text-xs text-blue-600 hover:text-blue-800 underline">
            View Deal →
          </a>
        </div>
      ` : ""}
    </div>
  `;
}

// ---------------------------------------------------------------------
// INTERESTING PEOPLE FUNCTIONS
// ---------------------------------------------------------------------

// Helper function to parse JSON array or comma-separated string
function parseArrayOrString(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value.filter(Boolean);
  if (typeof value === "string") {
    try {
      const parsed = JSON.parse(value);
      if (Array.isArray(parsed)) return parsed.filter(Boolean);
    } catch (e) {
      // Not JSON, try comma-separated
      return value
        .split(",")
        .map(s => s.trim())
        .filter(s => s && s.toLowerCase() !== "none");
    }
  }
  return [];
}

function collectCompanyNames(value) {
  const seen = new Set();
  const names = [];

  const addName = name => {
    if (!name) return;
    const cleaned = String(name).trim();
    if (!cleaned) return;
    const key = cleaned.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    names.push(cleaned);
  };

  const handleValue = (input, depth = 0) => {
    if (input == null || depth > 3) return;

    if (typeof input === "string") {
      const parsed = parseArrayOrString(input);
      if (parsed.length > 0) {
        parsed.forEach(addName);
      } else {
        addName(input);
      }
      return;
    }

    if (Array.isArray(input)) {
      input.forEach(item => handleValue(item, depth + 1));
      return;
    }

    if (typeof input === "object") {
      const candidates = [
        input.company_name,
        input.company,
        input.name,
        input.employer,
        input.organization,
        input.org,
      ];
      candidates.forEach(addName);

      if (input.company && typeof input.company === "object") {
        handleValue(input.company, depth + 1);
      }

      Object.values(input).forEach(val => {
        if (typeof val === "string" || Array.isArray(val)) {
          handleValue(val, depth + 1);
        }
      });
    }
  };

  handleValue(value);
  return names;
}

function getRawProfile(person) {
  if (!person) return null;
  const raw = person.raw_profile_data;
  if (!raw) return null;
  if (typeof raw === "object") return raw;
  if (typeof raw === "string") {
    try {
      return JSON.parse(raw);
    } catch (err) {
      console.warn("Failed to parse raw_profile_data", err);
      return null;
    }
  }
  return null;
}

function extractExperiences(person) {
  const profile = getRawProfile(person);
  if (!profile || !Array.isArray(profile.experienceList)) return [];

  return profile.experienceList
    .map(exp => {
      const name =
        exp.companyName ||
        exp.company?.name ||
        exp.company?.company_name ||
        exp.company;
      if (!name) return null;
      return {
        name: String(name).trim(),
        startDate: exp.startDate ? new Date(exp.startDate) : null,
        endDate: exp.endDate ? new Date(exp.endDate) : null,
      };
    })
    .filter(Boolean);
}

function getCurrentCompany(person) {
  const directCandidates = [
    person.current_company_name,
    person.current_company,
    person.company,
    person.current_employer,
    person.employer,
  ];

  for (const candidate of directCandidates) {
    if (candidate && String(candidate).trim()) {
      return String(candidate).trim();
    }
  }

  const listCandidates = [
    person.current_companies,
    person.companies,
    person.company_history,
    person.positions,
    person.work_history,
  ];

  for (const candidate of listCandidates) {
    const names = collectCompanyNames(candidate);
    if (names.length > 0) return names[0];
  }

  const experiences = extractExperiences(person);
  if (experiences.length > 0) {
    const now = new Date();
    const current = experiences
      .filter(exp => !exp.endDate || exp.endDate.getTime() >= now.getTime())
      .sort((a, b) => {
        const aStart = a.startDate ? a.startDate.getTime() : -Infinity;
        const bStart = b.startDate ? b.startDate.getTime() : -Infinity;
        return bStart - aStart;
      });

    if (current.length > 0) {
      return current[0].name;
    }

    const sortedByStart = [...experiences].sort((a, b) => {
      const aStart = a.startDate ? a.startDate.getTime() : -Infinity;
      const bStart = b.startDate ? b.startDate.getTime() : -Infinity;
      return bStart - aStart;
    });
    if (sortedByStart.length > 0) {
      return sortedByStart[0].name;
    }
  }

  const headline = person.headline || "";
  const headlineMatch = headline.match(/@([^|,•–—-]+)/);
  if (headlineMatch) {
    return headlineMatch[1].trim();
  }

  return "";
}

function getPreviousCompanies(person, currentCompany = "") {
  const sources = [
    person.previous_companies,
    person.past_companies,
    person.prior_companies,
    person.company_history,
    person.positions,
    person.work_history,
    person.employment_history,
  ];

  const names = [];

  const currentLower = currentCompany ? currentCompany.toLowerCase() : "";

  const experiences = extractExperiences(person);
  experiences.forEach(exp => {
    if (!exp.name) return;
    const key = exp.name.toLowerCase();
    if (currentLower && key === currentLower) return;
    names.push(exp.name);
  });

  sources.forEach(source => {
    collectCompanyNames(source).forEach(name => names.push(name));
  });

  const unique = [];
  const seen = new Set();

  names.forEach(name => {
    const key = name.toLowerCase();
    if (currentLower && key === currentLower) return;
    if (seen.has(key)) return;
    seen.add(key);
    unique.push(name);
  });

  return unique;
}

// Helper to render a badge list with limit
function renderBadgeList(values, { limit = 3, emptyText = "" } = {}) {
  if (!values || values.length === 0) return emptyText;
  const limited = values.slice(0, limit);
  const remaining = values.length - limited.length;
  const badges = limited.map(
    value => `<span class="text-xs bg-gray-100 text-gray-700 px-2 py-0.5 rounded-full">${value}</span>`
  );
  if (remaining > 0) {
    badges.push(`<span class="text-xs text-gray-500">+${remaining} more</span>`);
  }
  return badges.join("");
}

// Helper function to score person based on headline keywords
function scorePersonInterest(person) {
  const headline = (person.headline || "").toLowerCase();
  let score = 0;

  // High score: Acquisition indicators (10 points)
  const acquisitionPatterns = [
    /acq\. by/i,
    /acquired by/i,
    /\(acquired\)/i,
    /\(acq\. by/i,
    /\bacquired\b/i
  ];
  if (acquisitionPatterns.some(pattern => pattern.test(headline))) {
    score += 10;
  }

  // Strong: Founder (8 points)
  if (/\bfounder\b/i.test(headline)) {
    score += 8;
  }

  // Strong: Member of Technical Staff (8 points)
  if (/member of technical staff/i.test(headline) || /\bmts\b/i.test(headline)) {
    score += 8;
  }

  // Good: Working on something new, building, stealth (5 points each)
  if (/\bworking on something new\b/i.test(headline)) {
    score += 5;
  }
  if (/\bstealth\b/i.test(headline)) {
    score += 5;
  }
  // Building is good, but exclude "building X for Y" (employee context)
  if (/\bbuilding\b/i.test(headline) && !/\bbuilding\b.*\bfor\b/i.test(headline)) {
    score += 5;
  }

  // Good: Entrepreneur (5 points)
  if (/\bentrepreneur\b/i.test(headline)) {
    score += 5;
  }

  return score;
}

// Helper function to create person card HTML
function createPersonCardHTML(person) {
  const fullName = person.full_name || "Unknown";
  const headline = person.headline || "";
  const location = person.location || "";
  const currentCompany = getCurrentCompany(person);
  const pastCompanies = getPreviousCompanies(person, currentCompany);

  return `
    <div class="space-y-2">
      <div>
        <h3 class="font-semibold text-brand text-lg">${fullName}</h3>
        ${headline ? `<p class="text-xs text-gray-600 mt-0.5">${headline}</p>` : ""}
      </div>
      
      ${location || currentCompany ? `
        <div class="flex flex-wrap gap-x-4 gap-y-1 text-xs text-gray-600">
          ${location ? `<span>📍 ${location}</span>` : ""}
          ${currentCompany ? `<span>🏢 ${currentCompany}</span>` : ""}
        </div>
      ` : ""}
      
      ${pastCompanies.length > 0 ? `
        <div class="flex flex-wrap gap-1 text-[11px] text-gray-600">
          <span class="font-medium text-gray-700">Prev:</span>
          ${renderBadgeList(pastCompanies, { limit: 3 })}
        </div>
      ` : ""}
    </div>
  `;
}

// Load and display interesting people
async function loadInterestingPeople() {
  const loadingEl = $("peopleLoading");
  const resultsEl = $("peopleResults");
  const scrollEl = $("peopleScroll");

  if (!loadingEl || !resultsEl || !scrollEl) return;

  loadingEl.classList.remove("hidden");
  resultsEl.classList.add("hidden");
  scrollEl.innerHTML = "";

  try {
    const res = await fetch(`${API_URL}/api/interesting-people`);
    const json = await res.json();

    if (!json.success) {
      throw new Error(json.error || "Failed to load people");
    }

    let people = json.data || [];
    loadingEl.classList.add("hidden");

    if (!people.length) {
      resultsEl.classList.remove("hidden");
      scrollEl.innerHTML = `<p class="text-gray-500 px-4">No people found.</p>`;
      return;
    }

    // Score and sort people by interest score (highest first)
    people = people.map(person => ({
      ...person,
      _interestScore: scorePersonInterest(person)
    })).sort((a, b) => b._interestScore - a._interestScore);

    // Display people
    people.forEach((person, index) => {
      const card = document.createElement("div");
      card.className = "bg-gray-50 border border-gray-200 rounded-lg p-4 hover:shadow-md cursor-pointer transition-shadow";
      card.innerHTML = createPersonCardHTML(person);
      card.addEventListener("click", () => openPersonModal(person));
      scrollEl.appendChild(card);
    });

    resultsEl.classList.remove("hidden");

    // Automatically open the first person's details
    if (people.length > 0) {
      openPersonModal(people[0]);
    }
  } catch (err) {
    console.error("Failed to load interesting people", err);
    loadingEl.classList.add("hidden");
    resultsEl.classList.remove("hidden");
    scrollEl.innerHTML = `<p class="text-red-500 px-4">Error loading people: ${err.message}</p>`;
  }
}

// Open person detail modal
function openPersonModal(person) {
  const panel = $("personDetailPanel");
  const title = $("personDetailTitle");
  const body = $("personDetailBody");

  if (!panel || !title || !body) return;

  // Set title and headline
  if (person.headline) {
    title.innerHTML = `<div>${person.full_name || "Person Details"}</div><div class="text-sm font-normal text-gray-600 mt-1">${person.headline}</div>`;
  } else {
    title.textContent = person.full_name || "Person Details";
  }

  let html = `<div class="space-y-3 text-sm text-gray-700">`;

  // Main fields (excluding Full Name, Headline, LinkedIn ID, and Aviato ID)
  const linkedinUrl = ensureExternalUrl(person.linkedin_url);
  const currentCompany = getCurrentCompany(person);
  const fields = [
    ["Location", person.location],
    ["Current Company", currentCompany],
    ["LinkedIn", linkedinUrl ? `<a href="${linkedinUrl}" target="_blank" class="text-blue-600 underline hover:text-blue-800">${person.linkedin_url}</a>` : null],
    ["Last Updated", person.last_updated ? new Date(person.last_updated).toLocaleDateString() : null],
  ];

  for (const [label, value] of fields) {
    if (value) {
      html += `<p><strong>${label}:</strong> ${value}</p>`;
    }
  }

  // Highlight list
  const highlightList = parseArrayOrString(person.computed_highlight_list);
  if (highlightList.length > 0) {
    html += `<div class="mt-3"><strong class="text-gray-700">Highlights:</strong><div class="flex flex-wrap gap-2 mt-2">`;
    highlightList.forEach(h => {
      html += `<span class="text-xs bg-amber-100 text-amber-700 px-2 py-1 rounded-full">${h}</span>`;
    });
    html += `</div></div>`;
  }

  // Skills
  const skills = parseArrayOrString(person.skills);
  if (skills.length > 0) {
    html += `<div class="mt-3"><strong class="text-gray-700">Skills:</strong><div class="flex flex-wrap gap-2 mt-2">`;
    skills.forEach(skill => {
      html += `<span class="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded-full">${skill}</span>`;
    });
    html += `</div></div>`;
  }

  // Previous Companies
  const pastCompanies = getPreviousCompanies(person, currentCompany);
  if (pastCompanies.length > 0) {
    html += `<div class="mt-3"><strong class="text-gray-700">Previous Companies:</strong><div class="flex flex-wrap gap-2 mt-2">`;
    pastCompanies.forEach(company => {
      html += `<span class="text-xs bg-gray-100 text-gray-700 px-2 py-1 rounded-full">${company}</span>`;
    });
    html += `</div></div>`;
  }

  html += `</div>`;
  body.innerHTML = html;

  panel.classList.remove("hidden");
}

// ---------------------------------------------------------------------
// PROSPECTING FUNCTIONS
// ---------------------------------------------------------------------

// Store current prospecting results for export
let currentProspectingResults = [];

// Helper function to validate single value (no commas, semicolons, or multiple entries)
function validateSingleValue(value, fieldName) {
  if (!value) return null; // Empty is allowed
  
  // Check for commas or semicolons (common separators)
  if (value.includes(',') || value.includes(';')) {
    return `${fieldName} must contain only one value. Please remove commas or semicolons.`;
  }
  
  // Check for pipe separator
  if (value.includes('|')) {
    return `${fieldName} must contain only one value. Please remove pipe characters.`;
  }
  
  return null; // Valid
}

// Build query function - matches backend logic
function buildQuery(keywords, role, company) {
  return `site:linkedin.com/in/ "${keywords} ${role} ${company}"`;
}

// Search prospects function - performs actual Google search
async function searchProspects() {
  // Hide previous errors
  const errorBox = $("prospectingErrorBox");
  errorBox.classList.add("hidden");
  errorBox.textContent = "";

  const keywords = $("prospectingKeywords").value.trim();
  const role = $("prospectingRole").value.trim();
  const company = $("prospectingCompany").value.trim();

  // Validate single values
  const errors = [];
  const keywordError = validateSingleValue(keywords, "Keywords");
  if (keywordError) errors.push(keywordError);
  
  const roleError = validateSingleValue(role, "Role");
  if (roleError) errors.push(roleError);
  
  const companyError = validateSingleValue(company, "Company Name");
  if (companyError) errors.push(companyError);

  // Show errors if any
  if (errors.length > 0) {
    errorBox.textContent = errors.join(" ");
    errorBox.classList.remove("hidden");
    return; // Stop execution
  }

  // Show loading state
  $("prospectingLoading").classList.remove("hidden");
  $("prospectingResults").classList.add("hidden");
  $("prospectingScroll").innerHTML = "";

  try {
    const API_URL = "";
    const response = await fetch(`${API_URL}/api/prospecting/search`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ keywords, role, company }),
    });

    const data = await response.json();

    if (!data.success) {
      throw new Error(data.error || "Search failed");
    }

    // Store results for export
    currentProspectingResults = data.data || [];
    
    // Display results
    $("prospectingLoading").classList.add("hidden");
    displayProspectingResults(currentProspectingResults);

  } catch (err) {
    console.error("Prospecting search error:", err);
    $("prospectingLoading").classList.add("hidden");
    $("prospectingResults").classList.remove("hidden");
    errorBox.textContent = `Error: ${err.message}`;
    errorBox.classList.remove("hidden");
    $("prospectingScroll").innerHTML = `
      <p class="text-red-500 px-4">Error: ${err.message}</p>
    `;
  }
}

// Helper function to display prospecting results
function displayProspectingResults(results) {
  const scroll = $("prospectingScroll");
  scroll.innerHTML = "";

  if (!results || results.length === 0) {
    scroll.innerHTML = `<p class="text-gray-500 px-4 py-8 text-center">No results found.</p>`;
    $("prospectingResults").classList.remove("hidden");
    $("exportCsvBtn").classList.add("hidden");
    $("prospectingResultsHeader").textContent = "";
    return;
  }

  // Update result count header and show export button
  $("prospectingResultsHeader").textContent = `Found ${results.length} result${results.length !== 1 ? 's' : ''}`;
  $("exportCsvBtn").classList.remove("hidden");

  // Display all results
  results.forEach((result, index) => {
    const card = document.createElement("div");
    card.className = "bg-white border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow";
    
    const name = result.name || "Unknown";
    const jobTitle = result.job_title || "";
    const company = result.company || "";
    const link = result.link || "";
    const description = result.description || "";
    
    card.innerHTML = `
      <div class="space-y-2">
        <div class="flex items-start justify-between">
          <div class="flex-1">
            <h3 class="font-semibold text-brand text-lg">${name}</h3>
            ${jobTitle ? `<p class="text-sm text-gray-700 mt-1">${jobTitle}</p>` : ""}
          </div>
          ${link ? `<a href="${link}" target="_blank" rel="noopener noreferrer" 
                      class="ml-4 text-blue-600 hover:text-blue-800 text-sm font-medium whitespace-nowrap">
                      View Profile →
                    </a>` : ""}
        </div>
        ${description ? `<p class="text-xs text-gray-500 mt-2">${description}</p>` : ""}
      </div>
    `;
    scroll.appendChild(card);
  });

  $("prospectingResults").classList.remove("hidden");
}

// ============================================================================
// TASTE TREE FUNCTIONS - User-Centric Interface
// ============================================================================

let selectedUser = null;
let allUsers = [];
let userTags = {}; // Map of userName -> array of category paths
let allCategories = []; // Flat list of all categories
let pendingChanges = {}; // Map of userName -> {add: [...], remove: [...]}
let categoryTree = null; // Hierarchical tree structure for browsing
let browseExpandedNodes = new Set(); // Track expanded nodes in browse tree

// Load taste tree module - initialize users and categories
async function loadTasteTree() {
  const loadingEl = $("tasteTreeLoading");
  const errorEl = $("tasteTreeError");
  const contentEl = $("tasteTreeContent");

  if (!loadingEl || !errorEl || !contentEl) return;

  loadingEl.classList.remove("hidden");
  errorEl.classList.add("hidden");
  contentEl.classList.add("hidden");

  try {
    // Load users and categories in parallel
    const [usersRes, categoriesRes] = await Promise.all([
      fetch(`${API_URL || ""}/api/taste-tree/users`),
      fetch(`${API_URL || ""}/api/taste-tree/all-categories`)
    ]);

    const usersJson = await usersRes.json();
    const categoriesJson = await categoriesRes.json();

    if (!usersJson.success) {
      throw new Error(usersJson.error || "Failed to load users");
    }
    if (!categoriesJson.success) {
      throw new Error(categoriesJson.error || "Failed to load categories");
    }

    allUsers = usersJson.data || [];
    allCategories = categoriesJson.data || [];

    // Load the full tree structure for browsing
    const treeRes = await fetch(`${API_URL || ""}/api/taste-tree`);
    const treeJson = await treeRes.json();
    if (treeJson.success && treeJson.data) {
      categoryTree = treeJson.data;
    }

    // Load tag counts for all users in parallel
    await loadAllUserTagCounts();

    loadingEl.classList.add("hidden");
    contentEl.classList.remove("hidden");

    // Render users list
    renderUsersList();
  } catch (err) {
    console.error("Failed to load taste tree", err);
    loadingEl.classList.add("hidden");
    errorEl.textContent = `Error loading taste tree: ${err.message}`;
    errorEl.classList.remove("hidden");
  }
}

// Load tag counts for all users
async function loadAllUserTagCounts() {
  if (!allUsers || allUsers.length === 0) return;

  // Load tag counts for all users in parallel
  const tagCountPromises = allUsers.map(async (userName) => {
    try {
      const res = await fetch(`${API_URL || ""}/api/taste-tree/user-tags/${encodeURIComponent(userName)}`);
      const json = await res.json();
      if (json.success && json.data) {
        userTags[userName] = json.data;
        return { userName, count: json.data.length };
      }
      return { userName, count: 0 };
    } catch (err) {
      console.error(`Failed to load tags for ${userName}`, err);
      return { userName, count: 0 };
    }
  });

  await Promise.all(tagCountPromises);
}

// Render the users list in the left panel
function renderUsersList() {
  const usersListEl = $("usersList");
  if (!usersListEl) return;

  usersListEl.innerHTML = "";

  if (allUsers.length === 0) {
    usersListEl.innerHTML = `<p class="text-gray-500 text-sm text-center py-4">No users found</p>`;
    return;
  }

  allUsers.forEach(userName => {
    const userCard = document.createElement("div");
    userCard.className = `user-card p-3 rounded-lg border cursor-pointer transition-colors ${
      selectedUser === userName 
        ? "bg-blue-100 border-blue-500 text-blue-700" 
        : "bg-white border-gray-200 hover:bg-gray-50"
    }`;
    userCard.onclick = () => selectUser(userName);
    
    // Get tag count for this user (now loaded upfront)
    const tagCount = userTags[userName] ? userTags[userName].length : 0;
    
    userCard.innerHTML = `
      <div class="font-semibold">${userName}</div>
      <div class="text-xs text-gray-600 mt-1">${tagCount} tag${tagCount !== 1 ? 's' : ''}</div>
    `;
    
    usersListEl.appendChild(userCard);
  });
}

// Filter users based on search query
function filterUsers() {
  const searchInput = document.getElementById("userSearchInput");
  if (!searchInput) return;
  
  const query = searchInput.value.toLowerCase().trim();
  const userCards = document.querySelectorAll(".user-card");
  
  userCards.forEach(card => {
    const userName = card.querySelector(".font-semibold").textContent.toLowerCase();
    if (userName.includes(query)) {
      card.style.display = "";
    } else {
      card.style.display = "none";
    }
  });
}

// Select a user and load their tags
async function selectUser(userName) {
  selectedUser = userName;
  
  // Update UI
  document.querySelectorAll(".user-card").forEach(card => {
    const cardUserName = card.querySelector(".font-semibold").textContent;
    if (cardUserName === userName) {
      card.className = "user-card p-3 rounded-lg border cursor-pointer transition-colors bg-blue-100 border-blue-500 text-blue-700";
    } else {
      card.className = "user-card p-3 rounded-lg border cursor-pointer transition-colors bg-white border-gray-200 hover:bg-gray-50";
    }
  });

  // Show user tags panel
  $("noUserSelected").classList.add("hidden");
  $("userTagsPanel").classList.remove("hidden");
  $("selectedUserName").textContent = userName;

  // Load user tags
  await loadUserTags(userName);
}

// Load tags for a specific user
async function loadUserTags(userName) {
  try {
    const res = await fetch(`${API_URL || ""}/api/taste-tree/user-tags/${encodeURIComponent(userName)}`);
    const json = await res.json();

    if (!json.success) {
      throw new Error(json.error || "Failed to load user tags");
    }

    const tags = json.data || [];
    userTags[userName] = tags;

    // Update tag count in user card
    const userCards = document.querySelectorAll(".user-card");
    userCards.forEach(card => {
      const cardUserName = card.querySelector(".font-semibold").textContent;
      if (cardUserName === userName) {
        const countEl = card.querySelector(".text-xs");
        if (countEl) {
          countEl.textContent = `${tags.length} tag${tags.length !== 1 ? 's' : ''}`;
        }
      }
    });

    // Render current tags
    renderCurrentTags(tags);
    
    // Update header
    $("selectedUserTagCount").textContent = `${tags.length} categor${tags.length !== 1 ? 'ies' : 'y'} tagged`;

    // Reset pending changes for this user
    if (!pendingChanges[userName]) {
      pendingChanges[userName] = { add: [], remove: [] };
    }
    updatePendingChangesIndicator();
    
    // Refresh browse tree if in browse mode
    if (!$("browseMode").classList.contains("hidden")) {
      renderBrowseTree();
    }
  } catch (err) {
    console.error("Failed to load user tags", err);
    alert(`Error loading tags: ${err.message}`);
  }
}

// Render current tags for the selected user
function renderCurrentTags(tags) {
  const tagsListEl = $("currentTagsList");
  if (!tagsListEl) return;

  tagsListEl.innerHTML = "";

  if (tags.length === 0) {
    tagsListEl.innerHTML = `<p class="text-gray-400 text-sm">No tags assigned</p>`;
    return;
  }

  tags.forEach(path => {
    const tagEl = document.createElement("div");
    tagEl.className = "flex items-center gap-2 bg-white border border-gray-300 rounded-lg px-3 py-2";
    tagEl.dataset.categoryPath = JSON.stringify(path);
    
    const isPendingRemove = pendingChanges[selectedUser]?.remove.some(p => JSON.stringify(p) === JSON.stringify(path));
    
    tagEl.innerHTML = `
      <div class="flex-1">
        <div class="font-medium text-sm text-gray-800">${path[path.length - 1]}</div>
        <div class="text-xs text-gray-500">${path.join(" > ")}</div>
      </div>
      <button
        class="remove-tag-btn text-red-500 hover:text-red-700 text-lg font-bold px-2"
        title="Remove tag"
      >
        ×
      </button>
    `;
    
    // Attach click handler
    const removeBtn = tagEl.querySelector('.remove-tag-btn');
    if (removeBtn) {
      removeBtn.onclick = () => {
        const path = JSON.parse(tagEl.dataset.categoryPath);
        removeTagFromUser(path);
      };
    }
    
    if (isPendingRemove) {
      tagEl.classList.add("opacity-50", "line-through");
    }
    
    tagsListEl.appendChild(tagEl);
  });
}

// Remove a tag from user (adds to pending changes)
function removeTagFromUser(categoryPath) {
  if (!selectedUser) return;

  if (!pendingChanges[selectedUser]) {
    pendingChanges[selectedUser] = { add: [], remove: [] };
  }

  // Remove from add list if it was pending to be added
  pendingChanges[selectedUser].add = pendingChanges[selectedUser].add.filter(
    p => JSON.stringify(p) !== JSON.stringify(categoryPath)
  );

  // Add to remove list if not already there
  const alreadyInRemove = pendingChanges[selectedUser].remove.some(
    p => JSON.stringify(p) === JSON.stringify(categoryPath)
  );
  if (!alreadyInRemove) {
    pendingChanges[selectedUser].remove.push(categoryPath);
  }

  // Re-render to show pending state
  renderCurrentTags(userTags[selectedUser] || []);
  
  // Re-render browse tree if it's visible
  if (!$("browseMode").classList.contains("hidden")) {
    renderBrowseTree();
  }
  
  updatePendingChangesIndicator();
}

// Switch between search and browse modes
function switchTagMode(mode) {
  const searchMode = $("searchMode");
  const browseMode = $("browseMode");
  const searchTabBtn = $("searchTabBtn");
  const browseTabBtn = $("browseTabBtn");

  if (mode === "search") {
    searchMode.classList.remove("hidden");
    browseMode.classList.add("hidden");
    searchTabBtn.classList.add("border-blue-600", "text-blue-600");
    searchTabBtn.classList.remove("border-transparent", "text-gray-600");
    browseTabBtn.classList.remove("border-blue-600", "text-blue-600");
    browseTabBtn.classList.add("border-transparent", "text-gray-600");
  } else {
    searchMode.classList.add("hidden");
    browseMode.classList.remove("hidden");
    browseTabBtn.classList.add("border-blue-600", "text-blue-600");
    browseTabBtn.classList.remove("border-transparent", "text-gray-600");
    searchTabBtn.classList.remove("border-blue-600", "text-blue-600");
    searchTabBtn.classList.add("border-transparent", "text-gray-600");
    
    // Render browse tree if not already rendered
    if (categoryTree && $("categoryBrowseTree").children.length === 0) {
      renderBrowseTree();
    }
  }
}

// Render the hierarchical category tree for browsing
function renderBrowseTree() {
  const container = $("categoryBrowseTree");
  if (!container || !categoryTree) return;

  container.innerHTML = "";
  
  // Build tree structure from flat categories
  const tree = buildCategoryTree(allCategories);
  
  // Render tree recursively
  renderBrowseTreeRecursive(tree, container, []);
}

// Build hierarchical tree structure from flat category list
function buildCategoryTree(categories) {
  const tree = {};
  
  categories.forEach(cat => {
    let current = tree;
    cat.path.forEach((segment, index) => {
      if (!current[segment]) {
        current[segment] = {
          name: segment,
          path: cat.path.slice(0, index + 1),
          fullPath: cat.fullPath,
          children: {},
          isLeaf: index === cat.path.length - 1
        };
      }
      current = current[segment].children;
    });
  });
  
  return tree;
}

// Render browse tree recursively
function renderBrowseTreeRecursive(tree, container, parentPath = []) {
  const entries = Object.entries(tree).sort((a, b) => a[0].localeCompare(b[0]));
  
  entries.forEach(([name, node]) => {
    const currentPath = [...parentPath, name];
    const pathKey = currentPath.join("|");
    const isExpanded = browseExpandedNodes.has(pathKey);
    const hasChildren = Object.keys(node.children).length > 0;
    
    // Check if already tagged
    const currentTags = userTags[selectedUser] || [];
    const isTagged = currentTags.some(t => JSON.stringify(t) === JSON.stringify(currentPath));
    const isPendingAdd = pendingChanges[selectedUser]?.add.some(
      p => JSON.stringify(p) === JSON.stringify(currentPath)
    );
    const isPendingRemove = pendingChanges[selectedUser]?.remove.some(
      p => JSON.stringify(p) === JSON.stringify(currentPath)
    );
    
    const nodeEl = document.createElement("div");
    nodeEl.className = "browse-tree-node mb-1";
    nodeEl.dataset.path = pathKey;
    nodeEl.dataset.categoryPath = JSON.stringify(currentPath);
    
    const indentPx = parentPath.length * 20;
    if (indentPx > 0) {
      nodeEl.style.marginLeft = `${indentPx}px`;
    }
    
    nodeEl.innerHTML = `
      <div class="flex items-center gap-2 p-2 rounded hover:bg-gray-100 ${isTagged ? 'bg-blue-50' : ''}">
        ${hasChildren ? `
          <button
            class="expand-browse-btn text-gray-500 hover:text-gray-700 text-xs w-5 h-5 flex items-center justify-center"
            onclick="toggleBrowseNode('${pathKey}')"
          >
            ${isExpanded ? '▼' : '▶'}
          </button>
        ` : '<span class="w-5"></span>'}
        <span class="flex-1 text-sm ${isTagged ? 'text-blue-700 font-medium' : 'text-gray-700'}">${name}</span>
        ${isTagged ? `
          <span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded">Tagged</span>
        ` : `
          <button
            class="add-from-browse-btn px-2 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 ${isPendingAdd ? 'opacity-50 cursor-not-allowed' : ''}"
            ${isPendingAdd ? 'disabled' : ''}
          >
            ${isPendingAdd ? 'Added' : 'Add'}
          </button>
        `}
      </div>
      <div class="browse-children ${isExpanded ? '' : 'hidden'}" data-path="${pathKey}"></div>
    `;
    
    // Attach click handler for add button
    const addBtn = nodeEl.querySelector('.add-from-browse-btn');
    if (addBtn) {
      addBtn.onclick = (e) => {
        e.stopPropagation();
        addTagToUser(currentPath);
        // Re-render to update state
        renderBrowseTree();
      };
    }
    
    container.appendChild(nodeEl);
    
    // Render children if expanded
    if (hasChildren && isExpanded) {
      const childrenContainer = nodeEl.querySelector(`.browse-children[data-path="${pathKey}"]`);
      renderBrowseTreeRecursive(node.children, childrenContainer, currentPath);
    }
  });
}

// Toggle browse tree node expansion
function toggleBrowseNode(pathKey) {
  const isExpanded = browseExpandedNodes.has(pathKey);
  const nodeEl = document.querySelector(`.browse-tree-node[data-path="${pathKey}"]`);
  if (!nodeEl) return;

  const childrenContainer = nodeEl.querySelector(`.browse-children[data-path="${pathKey}"]`);
  const expandBtn = nodeEl.querySelector(`.expand-browse-btn`);
  
  if (!childrenContainer || !expandBtn) return;

  if (isExpanded) {
    browseExpandedNodes.delete(pathKey);
    childrenContainer.classList.add("hidden");
    expandBtn.textContent = "▶";
  } else {
    browseExpandedNodes.add(pathKey);
    childrenContainer.classList.remove("hidden");
    expandBtn.textContent = "▼";
    
    // Render children if not already rendered
    if (childrenContainer.children.length === 0 && categoryTree) {
      const path = pathKey.split("|");
      const tree = buildCategoryTree(allCategories);
      let current = tree;
      for (const segment of path) {
        if (current[segment]) {
          current = current[segment].children;
        } else {
          return;
        }
      }
      renderBrowseTreeRecursive(current, childrenContainer, path);
    }
  }
}

// Filter browse tree
function filterBrowseTree() {
  const filterInput = document.getElementById("browseFilterInput");
  if (!filterInput) return;
  
  const query = filterInput.value.toLowerCase().trim();
  const nodes = document.querySelectorAll(".browse-tree-node");
  
  if (!query) {
    nodes.forEach(node => {
      node.style.display = "";
    });
    return;
  }
  
  nodes.forEach(node => {
    const name = node.dataset.path.split("|").pop().toLowerCase();
    const fullPath = node.querySelector(".text-sm")?.textContent.toLowerCase() || "";
    const matches = name.includes(query) || fullPath.includes(query);
    node.style.display = matches ? "" : "none";
  });
}

// Search categories and show results
function searchCategories() {
  const searchInput = document.getElementById("tagSearchInput");
  const resultsEl = $("tagSearchResults");
  if (!searchInput || !resultsEl) return;

  const query = searchInput.value.toLowerCase().trim();
  
  if (!query) {
    resultsEl.classList.add("hidden");
    return;
  }

  // Filter categories
  const currentTags = userTags[selectedUser] || [];
  const currentTagPaths = currentTags.map(t => JSON.stringify(t));
  
  const filtered = allCategories.filter(cat => {
    const matchesSearch = cat.name.toLowerCase().includes(query) || 
                         cat.fullPath.toLowerCase().includes(query);
    const alreadyTagged = currentTagPaths.includes(JSON.stringify(cat.path));
    return matchesSearch && !alreadyTagged;
  });

  resultsEl.innerHTML = "";
  
  if (filtered.length === 0) {
    resultsEl.innerHTML = `<p class="text-gray-500 text-sm text-center py-4">No matching categories found</p>`;
    resultsEl.classList.remove("hidden");
    return;
  }

  filtered.slice(0, 10).forEach(cat => {
    const resultEl = document.createElement("div");
    resultEl.className = "flex items-center justify-between p-3 border-b border-gray-200 hover:bg-gray-50";
    resultEl.dataset.categoryPath = JSON.stringify(cat.path);
    
    const isPendingAdd = pendingChanges[selectedUser]?.add.some(
      p => JSON.stringify(p) === JSON.stringify(cat.path)
    );
    
    resultEl.innerHTML = `
      <div class="flex-1">
        <div class="font-medium text-sm text-gray-800">${cat.name}</div>
        <div class="text-xs text-gray-500">${cat.fullPath}</div>
      </div>
      <button
        class="add-tag-btn px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 ${isPendingAdd ? 'opacity-50 cursor-not-allowed' : ''}"
        ${isPendingAdd ? 'disabled' : ''}
      >
        ${isPendingAdd ? 'Added' : 'Add'}
      </button>
    `;
    
    // Attach click handler
    const addBtn = resultEl.querySelector('.add-tag-btn');
    if (addBtn) {
      addBtn.onclick = () => {
        const path = JSON.parse(resultEl.dataset.categoryPath);
        addTagToUser(path);
      };
    }
    
    resultsEl.appendChild(resultEl);
  });

  resultsEl.classList.remove("hidden");
}

// Add a tag to user (adds to pending changes)
function addTagToUser(categoryPath) {
  if (!selectedUser) return;

  if (!pendingChanges[selectedUser]) {
    pendingChanges[selectedUser] = { add: [], remove: [] };
  }

  // Remove from remove list if it was pending to be removed
  pendingChanges[selectedUser].remove = pendingChanges[selectedUser].remove.filter(
    p => JSON.stringify(p) !== JSON.stringify(categoryPath)
  );

  // Add to add list if not already there
  const alreadyInAdd = pendingChanges[selectedUser].add.some(
    p => JSON.stringify(p) === JSON.stringify(categoryPath)
  );
  if (!alreadyInAdd) {
    pendingChanges[selectedUser].add.push(categoryPath);
  }

  // Re-render search results to show pending state
  searchCategories();
  
  // Re-render browse tree if it's visible
  if (!$("browseMode").classList.contains("hidden")) {
    renderBrowseTree();
  }
  
  updatePendingChangesIndicator();
}

// Update pending changes indicator and save button
function updatePendingChangesIndicator() {
  if (!selectedUser) return;

  const changes = pendingChanges[selectedUser] || { add: [], remove: [] };
  const totalChanges = changes.add.length + changes.remove.length;

  const indicatorEl = $("pendingChangesIndicator");
  const countEl = $("pendingChangesCount");
  const saveBtn = $("saveUserChangesBtn");

  if (totalChanges > 0) {
    indicatorEl.classList.remove("hidden");
    if (countEl) {
      countEl.textContent = totalChanges;
    }
    if (saveBtn) {
      saveBtn.disabled = false;
    }
  } else {
    indicatorEl.classList.add("hidden");
    if (saveBtn) {
      saveBtn.disabled = true;
    }
  }
}

// Save all pending changes for the selected user
async function saveUserChanges() {
  if (!selectedUser) return;

  const changes = pendingChanges[selectedUser];
  if (!changes || (changes.add.length === 0 && changes.remove.length === 0)) {
    return;
  }

  const saveBtn = $("saveUserChangesBtn");
  if (saveBtn) {
    saveBtn.disabled = true;
    saveBtn.textContent = "Saving...";
  }

  try {
    const res = await fetch(`${API_URL || ""}/api/taste-tree/batch-update-user`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        user_name: selectedUser,
        add_paths: changes.add,
        remove_paths: changes.remove
      })
    });

    const json = await res.json();

    if (!json.success) {
      throw new Error(json.error || "Failed to save changes");
    }

    // Clear pending changes
    pendingChanges[selectedUser] = { add: [], remove: [] };
    
    // Reload user tags to reflect changes
    await loadUserTags(selectedUser);
    
    // Update tag count in user card
    const userCards = document.querySelectorAll(".user-card");
    userCards.forEach(card => {
      const cardUserName = card.querySelector(".font-semibold").textContent;
      if (cardUserName === selectedUser) {
        const countEl = card.querySelector(".text-xs");
        if (countEl) {
          const tagCount = userTags[selectedUser] ? userTags[selectedUser].length : 0;
          countEl.textContent = `${tagCount} tag${tagCount !== 1 ? 's' : ''}`;
        }
      }
    });
    
    // Clear search
    const searchInput = document.getElementById("tagSearchInput");
    if (searchInput) {
      searchInput.value = "";
      $("tagSearchResults").classList.add("hidden");
    }
    
    // Clear browse filter and refresh browse tree
    const browseFilterInput = document.getElementById("browseFilterInput");
    if (browseFilterInput) {
      browseFilterInput.value = "";
    }
    if (!$("browseMode").classList.contains("hidden")) {
      renderBrowseTree();
    }

    // Show success feedback
    if (saveBtn) {
      saveBtn.textContent = "Saved!";
      setTimeout(() => {
        saveBtn.textContent = "Save Changes";
        saveBtn.disabled = true;
      }, 2000);
    }
  } catch (err) {
    console.error("Failed to save user changes", err);
    alert(`Error saving changes: ${err.message}`);
    if (saveBtn) {
      saveBtn.disabled = false;
      saveBtn.textContent = "Save Changes";
    }
  }
}


// Export prospecting results to CSV
function exportProspectingResultsToCSV() {
  if (!currentProspectingResults || currentProspectingResults.length === 0) {
    alert("No results to export");
    return;
  }

  // Define CSV headers
  const headers = ["Name", "Job Title", "Company", "LinkedIn URL", "Description"];
  
  // Convert results to CSV rows
  const csvRows = [
    headers.join(","), // Header row
    ...currentProspectingResults.map(result => {
      const escapeCSV = (field) => {
        if (!field) return "";
        // Escape quotes and wrap in quotes if contains comma, quote, or newline
        const str = String(field);
        if (str.includes(",") || str.includes('"') || str.includes("\n")) {
          return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
      };
      
      return [
        escapeCSV(result.name || ""),
        escapeCSV(result.job_title || ""),
        escapeCSV(result.company || ""),
        escapeCSV(result.link || ""),
        escapeCSV(result.description || "")
      ].join(",");
    })
  ];

  // Create CSV content
  const csvContent = csvRows.join("\n");
  
  // Create blob and download
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  const url = URL.createObjectURL(blob);
  
  // Generate filename with timestamp
  const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, "-");
  link.setAttribute("href", url);
  link.setAttribute("download", `prospecting_results_${timestamp}.csv`);
  link.style.visibility = "hidden";
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up the URL object
  URL.revokeObjectURL(url);
}

</script>


</body>
</html>
